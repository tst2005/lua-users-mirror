<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>lua-users wiki: Classes As Constructor Closures</TITLE>
<LINK TYPE="text/css" REL="stylesheet" HREF="../styles/main.css">
</HEAD>
<BODY ><table width="100%" border="0"> <tr><td align=left width="100%"><h1><a href="/cgi-bin/wiki.pl?action=search&amp;string=ClassesAsConstructorClosures&amp;body=1" title="List pages referring to ClassesAsConstructorClosures">Classes As Constructor Closures</a></h1></td><td align=right>
    <table cellpadding="0" cellspacing="0" border="0" width="1%">
      <tbody>
        <tr>
            <td><a href="../index.html">
            <img src="../images/nav-logo.png" alt="lua-users home" width="177" height="40" border="0"></a></td>
        </tr>
        <tr>
            <td>
            <table cellpadding="0" cellspacing="0" border="0" width="100%">
                <tbody>
                <tr>
                    <td><img src="../images/nav-elbow.png" alt="" width="48" height="40"></td>
                    <td nowrap valign="middle" width="100%">
                        <a href="../wiki/index.html" class="nav">wiki</a></td>
                </tr>
                </tbody>
            </table>
            </td>
        </tr>
      </tbody>
    </table>
<form method="post" action="../wiki/FindPage.html" enctype="application/x-www-form-urlencoded" style="display:inline; margin:0;">
<input type="hidden" name="action" value="search"  /><input type="text" name="string"  size="20" style="" id="search_query1" /><input type="hidden" name="title" value="1"  /><input type="submit" name=".submit" value="Search" /><input type="hidden" name="body" value="on"  /></form></td></tr> </table>
<br clear=all>
<H3>Introduction</H3>
<p>
In ten years or more of Lua programming, I have experimented with numerous approaches to Object Orientation (OO) from "Programming in Lua", "Lua Programming Gems" and this wiki as well as schemes of my own, some with extensive 'C' support libraries. I have eventually standardised on the scheme outlined in this paper which is very flexible and relatively simple, can be implemented entirely in Lua and possesses some desirable OO characteristics that I've not seen in other Lua implementations.
<p>
<H3>Desirable OO Characteristics</H3>
<p>
It is commonly agreed that an OO system should provide encapsulation of multiple values (fields) and functions operating on those fields (methods). It is fairly commonly agreed that the system should provide an easy way of generating multiple objects sharing characteristics (most commonly method implementations). Classes or prototypes are two ways of implementing this.
<p>
I also want my classes to be seamless extensions of the Lua type system. In a pure OO language, there would be no distinction between types and classes, but a good compromise for Lua is for classes to be types but not vice versa. Given an unknown Lua value, we will need a function which can determine if it is of a specified class or type.
<p>
Another desirable characteristic is inter-working between classes and objects created in 'C' using the Lua API and those created in pure Lua. This allows 'C' libraries to provide classes and functions or methods defined in those libraries to create and return objects. It should ideally also be possible for 'C' code to create objects from classes defined in Lua.
<p>
<H3>Classes implemented as Constructor Closures</H3>
<p>
The crux of the scheme I propose in this paper is that classes are implemented as Lua function closures that return a new object of the class when executed. All the resources required to create an object are stored in upvalues of the class closure or passed as parameters to the closure function. This means that classes are first-class Lua values independent of their storage.
<p>
Some characterised upvalues must be present in all classes to support type matching. This is referred to as the TID, for Type ID. It must also be possible to derive a TID value from objects generated by the classes so that a generic predicate function can match an object with its class. By the simple expedient of defining the TID of values which are not classes or objects to be the Lua type name, this scheme can be extended so all Lua values have a TID and can be type-matched using the same predicate function.
<p>
A nice consequence of this scheme is a constructor syntax for objects that represent collections. For example, assuming the definition of a class called List, we can write:
<p>
<DL>
<dt><dd><pre class="code">


mylist = List{<span class="string">"ham"</span>, <span class="string">"eggs"</span>, <span class="string">"toast"</span>}

        

</pre>

</DL>
<p>
This uses a standard Lua syntax shortcut to allow the function call braces to be omitted. Within the List function, we can detect that one parameter has been passed, a table with no metatable (call this a 'rawtable'), and in this case convert it in place into an object without having to copy the entries. I think this seems like a very natural extension of the Lua table constructor syntax. Alternative construction syntaxes can also, or alternatively, be provided using other parameter signatures.
<p>
<H3>Creating Classes and Objects</H3>
<p>
Having been quite prescriptive in defining a class implementation, we can be much more flexible about the object implementation whilst still preserving universal type matching. In this section, I will show that the major object patterns suggested in the literature can all be accommodated within this scheme.
<p>
Firstly, I will demonstrate a class that produces metatable-based objects. In this pattern, the object is a Lua table (or possibly a userdata if implemented in 'C') with a metatable common to all objects of the same class. The methods and metamethods of the class are stored in this metatable while the fields are stored in the object table. The metatable is also the class TID.
<p>
<DL>
<dt><dd><pre class="code">


<span class="keyword">do</span>  <span class="comment">-- Class 'MetaBaseClass'</span>

  <span class="keyword">local</span> _TID = class.newmeta()



  <span class="comment">-- Class Closure:</span>

  <span class="keyword">local</span> _C = <span class="keyword">function</span>(p1)

    <span class="keyword">local</span> o

    <span class="keyword">if</span> class.istype(p1, <span class="string">'rawtable'</span>) <span class="keyword">then</span> o = p1 <span class="keyword">else</span> o = {} <span class="keyword">end</span>

    o.value = o.value <span class="keyword">or</span> 0

    <span class="library">setmetatable</span>(o, _TID)

    <span class="keyword">return</span> o

  <span class="keyword">end</span>



  <span class="comment">-- Methods:</span>

  <span class="keyword">function</span> _TID:mymethod()

    class.checkmethod(self, _C)

    <span class="library">print</span>(<span class="string">"Executing 'mymethod'"</span>)

  <span class="keyword">end</span>



  <span class="comment">-- Metamethods:</span>

  <span class="keyword">function</span> _TID.__add(p1, p2)

    class.checkmethod(p1, _C)

    class.checkmethod(p2, _C)

    <span class="keyword">local</span> rv = _C()

    rv.value = p1.value + p2.value

    <span class="library">print</span>(<span class="string">"Executing add metamethod"</span>)

    <span class="keyword">return</span> rv

  <span class="keyword">end</span>

  

  <span class="comment">-- Class Closure is a first-class value, for example, store it as a global:</span>

  MetaBaseClass = _C

<span class="keyword">end</span> <span class="comment">-- Class 'MetaBaseClass'</span>



</pre>

</DL>
<p>
The function <code>class.newmeta()</code> is a simple helper function that creates a new metatable and sets the index metamethod to self-refer. <code>class.istype()</code> is a multi-purpose type testing predicate and <code>class.checkmethod()</code> wraps this test and raises an error if the predicate is false (I will show an implementation of these functions later in this paper). Notice that routine use of <code>class.checkmethod</code> also means that all methods of a class hold upvalue references to the class itself facilitating creation of return parameters of the same class.
<p>
To create objects, just call the class:
<p>
<DL>
<dt><dd><pre class="code">


obj1 = MetaBaseClass{value = 13}

obj2 = MetaBaseClass{value = 10}

obj1:mymethod()

obj3 = obj1 + obj2

<span class="library">print</span>(obj3.value, 23)



</pre>

</DL>
<p>
To support single inheritance, <code>class.newmeta()</code> can be extended to take a parent class. This gets the parent TID (which is also its metatable) and sets it as the metatable of the new metatable (metametatable?). The parent class is also passed through unchanged as a syntax convenience:
<p>
<DL>
<dt><dd><pre class="code">
        

<span class="keyword">do</span>  <span class="comment">-- Class 'MetaChildClass' (Inherits MetaBaseClass)</span>

  <span class="keyword">local</span> _TID, _PC = class.newmeta(MetaBaseClass)



  <span class="comment">-- Class Closure:</span>

  <span class="keyword">local</span> _C = <span class="keyword">function</span>(p1)

    <span class="keyword">local</span> o = _PC(p1)

    <span class="comment">-- Extra initialisation for child class</span>

    <span class="library">setmetatable</span>(o, _TID)

    <span class="keyword">return</span> o

  <span class="keyword">end</span>



  <span class="comment">-- Methods are inherited automatically, but may be overridden.</span>



  <span class="comment">-- To inherit metamethods add explicit delegations:</span>

  _TID.__add = class.gettid(_PC).__add



  MetaChildClass = _C

<span class="keyword">end</span> <span class="comment">-- Class 'MetaChildClass'</span>



obj4 = MetaChildClass{value = 2}

obj4:mymethod()

<span class="library">print</span>((obj4 + obj1).value, 15)



</pre>

</DL>
<p>
The second pattern I will explore is prototype based. Classically, prototype approaches do not use the concept of 'class' at all; instead any object may act as a prototype for creating further objects. However I will use a standard class 'wrapper' around the prototype object and this will implement the table cloning code. The objects produced are Lua tables which contain the methods as well as the fields. If metamethods are required, a metatable will also be needed. To support type matching, a metatable will always be assigned even if it is empty.
<p>
<DL>
<dt><dd><pre class="code">


<span class="keyword">do</span>  <span class="comment">-- Class 'ProtoBaseClass'</span>

  <span class="keyword">local</span> _C, _PRT, _MTB = class.newproto()



  _PRT.field = <span class="string">"Hello from ProtoBaseClass"</span>



  <span class="keyword">function</span> _PRT:method()

    class.checkmethod(self, _C)

    <span class="library">print</span>(self.field)

  <span class="keyword">end</span>



  ProtoBaseClass = _C

<span class="keyword">end</span> <span class="comment">-- Class 'ProtoBaseClass'        </span>

        

</pre>

</DL>
<p>
The support function <code>class.newproto()</code> does most of the work in this case. It generates the class (function closure) and also returns references to the prototype table and the metatable ready to be populated. The class function is standardised, providing the functionality to clone the prototype table.
<p>
<DL>
<dt><dd><pre class="code">


obj5 = ProtoBaseClass()

obj5:method() <span class="comment">-- Prints 'Hello from ProtoBaseClass'</span>

obj6 = ProtoBaseClass{field=<span class="string">"Hello from obj6"</span>}

obj6:method() <span class="comment">-- Prints 'Hello from obj6'</span>

        

</pre>

</DL>
<p>
The standard class function takes an optional table parameter which can override (initialise) existing fields after they have been copied from the prototype.
<p>
This pattern can accommodate multiple inheritance (aggregation). The function <code>class.newproto()</code> can accept any number of object (table) parameters. These tables, and their metatables are merged to create the prototype table and metatable. Merge is in parameter order, so fields in later parameters override those with the same name in earlier parameters.
<p>
<DL>
<dt><dd><pre class="code">


<span class="keyword">do</span>  <span class="comment">-- Class 'ProtoAggregateClass'</span>

  <span class="keyword">local</span> _C, _PRT = class.newproto(ProtoBaseClass())

  _PRT.field = <span class="string">"Hello from ProtoAggregateClass"</span>

  ProtoAggregateClass = _C

<span class="keyword">end</span> <span class="comment">-- Class 'ProtoAggregateClass'        </span>

        

obj7 = ProtoAggregateClass()

obj7:method() <span class="comment">-- Prints 'Hello from ProtoAggregateClass'</span>



</pre>

</DL>
Note that in this pattern, inheritance is from an object of the parent class, not from the class itself.
<p>
The final pattern I will consider is the single function pattern. This has an object implementation similar to the class implementation (indeed a class is also an object of this type). The object has just one method which forms a closure with the fields stored as upvalues. This pattern does not support inheritance or metamethods.
<p>
<DL>
<dt><dd><pre class="code">


<span class="keyword">do</span> <span class="comment">-- Class 'FunctionClass'</span>

  <span class="keyword">local</span> _TID = <span class="string">"FunctionClass"</span>

  <span class="keyword">local</span> _TID_O = _TID

  <span class="keyword">local</span> _C = <span class="keyword">function</span>()

    <span class="keyword">local</span> tid = _TID

    <span class="keyword">local</span> val = 0

    <span class="keyword">return</span> <span class="keyword">function</span>()

      <span class="keyword">local</span> tid = _TID_O

      val = val + 1

      <span class="keyword">return</span> val

    <span class="keyword">end</span>

  <span class="keyword">end</span>

  FunctionClass = _C

<span class="keyword">end</span> <span class="comment">-- Class 'FunctionClass'</span>



obj8 = FunctionClass()

obj9 = FunctionClass()

<span class="library">print</span>(obj8(), 1)

<span class="library">print</span>(obj8(), 2)

<span class="library">print</span>(obj9(), 1)



</pre>

</DL>
<p>
In this pattern the TID is only used for type testing and is set as an arbitrary, but unique, string. Alternatively an empty table could be used. Because the implementation of the class and the object cannot be distinguished by Lua type, an extended tag convention is used. The tag is exactly "_TID" for the class, but has a suffix when used in the object. By this convention, a class is an object, but an object is not a class.
<p>
<H3>Support Functions</H3>
<p>
The TID can be derived from any Lua value using the following rules applied in order until a TID value is determined:
<p>
1. The TID is the non-nil value of any metamethod with the key '__tid'.
<p>
2. If the value is a table or userdata with a metatable, then the TID is the metatable.
<p>
3. If the value is a function with an upvalue with a name starting "_TID" (the tag), then that upvalue is the TID. This applies to function closures created in Lua.
<p>
4. If the value is a function with at least two unnamed upvalues, the first of which has a string value starting "_TID" (the tag), then the second upvalue is the TID. This applies to function closures created in 'C'.
<p>
5. Otherwise the Lua type of the value is the TID (which will be a string).
<p>
A class is a value with a TID determined by rule 3 or 4 with the tag being exactly "_TID". If the tag has any additional characters after "_TID" the value is an object, but not a class.
<p>
The following is a <code>gettid</code> implementation in pure Lua:
<p>
<DL>
<dt><dd><pre class="code">


<span class="keyword">do</span>

  <span class="keyword">local</span> getupvalue = <span class="library">require</span>(<span class="string">'debug'</span>).getupvalue

  class = class <span class="keyword">or</span> {}

  class.gettid = <span class="keyword">function</span>(v)

    <span class="comment">-- Rule 1: metafield</span>

    <span class="keyword">local</span> mt = <span class="library">getmetatable</span>(v)

    <span class="keyword">if</span> mt <span class="keyword">and</span> mt.__tid <span class="keyword">then</span> <span class="keyword">return</span> mt.__tid, <span class="string">"object_mf"</span> <span class="keyword">end</span>

    <span class="comment">-- Rule 2: metatable</span>

    <span class="keyword">if</span> mt <span class="keyword">and</span> (<span class="library">type</span>(v) == <span class="string">'userdata'</span> <span class="keyword">or</span> <span class="library">type</span>(v) == <span class="string">'table'</span>) <span class="keyword">then</span> 

      <span class="keyword">return</span> mt, <span class="string">"object_mt"</span>

    <span class="keyword">elseif</span> <span class="library">type</span>(v) == <span class="string">'function'</span> <span class="keyword">then</span>

      <span class="keyword">local</span> un, uv = getupvalue(v, 1)

      <span class="keyword">local</span> r = <span class="string">"class"</span>

      <span class="keyword">if</span> un <span class="keyword">and</span> un ~= <span class="string">""</span> <span class="keyword">then</span>

    <span class="comment">-- Rule 3: named upvalue</span>

        <span class="keyword">local</span> i = 2

        <span class="keyword">while</span> un <span class="keyword">and</span> un:sub(1,4) ~= <span class="string">"_TID"</span> <span class="keyword">do</span>

          un, uv = getupvalue(v, i)

          i = i + 1

        <span class="keyword">end</span>

        <span class="keyword">if</span> un <span class="keyword">and</span> #un ~= 4 <span class="keyword">then</span> r = <span class="string">"object_fn"</span> <span class="keyword">end</span>

      <span class="keyword">elseif</span> un <span class="keyword">and</span> <span class="library">type</span>(uv) == <span class="string">'string'</span> <span class="keyword">and</span> uv:sub(1,4) == <span class="string">"_TID"</span> <span class="keyword">then</span>

    <span class="comment">-- Rule 4: upvalue pair with tag</span>

        <span class="keyword">if</span> #uv ~= 4 <span class="keyword">then</span> r = <span class="string">"object_fn"</span> <span class="keyword">end</span>

        un, uv = getupvalue(v, 2)

      <span class="keyword">end</span>

      <span class="keyword">if</span> un <span class="keyword">then</span> <span class="keyword">return</span> uv, r <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="comment">-- Rule 5: Lua type name</span>

    <span class="keyword">return</span> <span class="library">type</span>(v), <span class="string">"type"</span>

  <span class="keyword">end</span>

<span class="keyword">end</span>



</pre>

</DL>
<p>
Having obtained the TID of the type (or class) and that of the value (or object), identity is determined by the following rules:
<p>
1. If the TID values are Lua equal functions, then that function is called passing it the value and the type. The result of the test is the Boolean value of the first return.
<p>
2. If the TID of the value is a table which has an entry with a key number 1, then the test is true if the TID of the type matches any entry keyed with a consecutive integer from 1 up.
<p>
3. If the TID of the value is a metatable and that of the type a table, then the test is true if the type TID matches the metatable, the metatable of the metatable and so on until a metatable has no metatable.
<p>
4. If none of the above applies, the test is a simple Lua equality test between the two TID values.
<p>
The following Lua function implements these matching rules and also incorporates standard Lua type detection using a string in place of the type parameter, some additional useful type predicates and the ability to determine if two arbitrary Lua values (except strings) are of the same type:
<p>
<DL>
<dt><dd><pre class="code">


class.istype = <span class="keyword">function</span>(vl, ty)

  <span class="keyword">local</span> tvl = <span class="library">type</span>(vl)

  <span class="keyword">local</span> tid1, isc = class.gettid(vl)

  <span class="keyword">if</span> <span class="library">type</span>(ty) == <span class="string">'string'</span> <span class="keyword">and</span> ty ~= <span class="string">""</span> <span class="keyword">then</span>

    <span class="keyword">if</span> ty == <span class="string">"class"</span> <span class="keyword">then</span>

      <span class="keyword">return</span> isc == <span class="string">'class'</span>

    <span class="keyword">elseif</span> ty == <span class="string">"object"</span> <span class="keyword">then</span>

      <span class="keyword">return</span> isc ~= <span class="string">'type'</span>

    <span class="keyword">elseif</span> ty == <span class="string">"rawtable"</span> <span class="keyword">then</span>

      <span class="keyword">if</span> tvl ~= <span class="string">"table"</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>

      <span class="keyword">return</span> <span class="library">getmetatable</span>(vl) == <span class="keyword">nil</span>

    <span class="keyword">elseif</span> ty == <span class="string">"callable"</span> <span class="keyword">then</span>

      <span class="keyword">if</span> tvl == <span class="string">"function"</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>

      <span class="keyword">local</span> m = <span class="library">getmetatable</span>(vl)

      <span class="keyword">if</span> <span class="keyword">not</span> m <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>

      <span class="keyword">return</span> <span class="library">type</span>(m.__call) == <span class="string">"function"</span>

    <span class="keyword">else</span>

      <span class="keyword">return</span> tvl == ty

    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="keyword">local</span> tid2 = class.gettid(ty)

  <span class="keyword">if</span> tid2 == tvl <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>

  <span class="keyword">if</span> <span class="library">type</span>(tid1) == <span class="string">'function'</span> <span class="keyword">and</span> tid1 == tid2 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">not</span> <span class="keyword">not</span> (tid1(vl, ty)) <span class="keyword">end</span>

  <span class="keyword">if</span> <span class="library">type</span>(tid1) == <span class="string">'table'</span> <span class="keyword">and</span> tid1[1] <span class="keyword">then</span>

    <span class="keyword">for</span> i=1, #tid1 <span class="keyword">do</span>

      <span class="keyword">if</span> tid2 == tid1[i] <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>

    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="keyword">if</span> isc == <span class="string">'object_mt'</span> <span class="keyword">and</span> <span class="library">type</span>(tid2) == <span class="string">'table'</span> <span class="keyword">then</span>

    <span class="keyword">repeat</span>

      <span class="keyword">if</span> tid2 == tid1 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>

      tid1 = <span class="library">getmetatable</span>(tid1)

    <span class="keyword">until</span> <span class="keyword">not</span> tid1

  <span class="keyword">end</span>

  <span class="keyword">return</span> tid1 == tid2

<span class="keyword">end</span>



class.checkmethod = <span class="keyword">function</span>(vl, ty)

  <span class="keyword">if</span> <span class="keyword">not</span> class.istype(vl, ty) <span class="keyword">then</span> <span class="library">error</span>(<span class="string">"Bad method call"</span>) <span class="keyword">end</span>

<span class="keyword">end</span>



<span class="comment">-- Export "istype" as a global since it will be widely used:</span>

istype = class.istype



</pre>

</DL>
<p>
The support function for the metatable pattern is now straightforward:
<p>
<DL>
<dt><dd><pre class="code">


class.newmeta = <span class="keyword">function</span>(pcl)

  <span class="keyword">local</span> mt = {}

  <span class="keyword">if</span> pcl <span class="keyword">then</span>

    <span class="keyword">if</span> <span class="keyword">not</span> class.istype(pcl,<span class="string">'class'</span>) <span class="keyword">then</span> <span class="library">error</span>(<span class="string">"Bad Parent Class"</span>) <span class="keyword">end</span>

    <span class="keyword">local</span> pmt = class.gettid(pcl)

    <span class="keyword">if</span> <span class="keyword">not</span> class.istype(pmt, <span class="string">'table'</span>) <span class="keyword">then</span> <span class="library">error</span>(<span class="string">"Bad Parent Class"</span>) <span class="keyword">end</span>

    <span class="library">setmetatable</span>(mt, pmt)

  <span class="keyword">else</span>

    <span class="library">setmetatable</span>(mt, <span class="keyword">nil</span>)

  <span class="keyword">end</span>

  <span class="library">rawset</span>(mt, <span class="string">"__index"</span>, mt)

  <span class="keyword">return</span> mt, pcl

<span class="keyword">end</span>



</pre>

</DL>
<p>
The support function for the prototype pattern is more subtle. The outer function merges the parent objects into a new class prototype table and metatable. This metatable is also the TID for the class. The metatables of the parent objects are also referenced under numeric keys in the new metatable, which allows the <code>istype</code> function to match objects of this class with objects of any of its parent classes, or classes enclosing these objects. The inner function returned in the class closure copies the prototype upvalue into a new object table, performs a final merge using any initialisation table, and sets the TID upvalue as the metatable for the new object.
<p>
<DL>
<dt><dd><pre class="code">


class.newproto = <span class="keyword">function</span>(...)

  <span class="keyword">local</span> _TID, _PRT, pmt = {}, {}, <span class="keyword">nil</span>

  <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="library">ipairs</span>{...} <span class="keyword">do</span>

    <span class="keyword">if</span> <span class="library">type</span>(t) ~= <span class="string">'table'</span> <span class="keyword">then</span> <span class="library">error</span>(<span class="string">"prototype must be table"</span>) <span class="keyword">end</span>

    pmt = <span class="library">getmetatable</span>(t)

    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="library">pairs</span>(t) <span class="keyword">do</span> _PRT[k] = v <span class="keyword">end</span>

    <span class="keyword">if</span> pmt <span class="keyword">then</span> 

      <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="library">pairs</span>(pmt) <span class="keyword">do</span> _TID[k] = v <span class="keyword">end</span>

      _TID[#_TID + 1] = pmt

    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="keyword">local</span> _C = <span class="keyword">function</span>(init)

    <span class="keyword">local</span> tid, prt, ob = _TID, _PRT, {}

    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="library">pairs</span>(prt) <span class="keyword">do</span> ob[k] = v <span class="keyword">end</span>

    <span class="keyword">if</span> init <span class="keyword">then</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="library">pairs</span>(init) <span class="keyword">do</span>

      <span class="keyword">if</span> ob[k] == <span class="keyword">nil</span> <span class="keyword">then</span>

        <span class="library">error</span>(<span class="string">"attempt to initialise non-existant field: "</span> .. k)

      <span class="keyword">end</span>

      <span class="keyword">if</span> <span class="library">type</span>(k) ~= <span class="string">'string'</span> <span class="keyword">or</span> k:sub(1,1) == <span class="string">'_'</span> <span class="keyword">then</span>

        <span class="library">error</span>(<span class="string">"attempt to initialise private field: "</span> .. k)

      <span class="keyword">end</span>

      ob[k] = v

    <span class="keyword">end</span> <span class="keyword">end</span>

    <span class="library">setmetatable</span>(ob, tid)

    <span class="keyword">return</span> ob

  <span class="keyword">end</span>

  <span class="keyword">return</span> _C, _PRT, _TID

<span class="keyword">end</span>

                

</pre>

</DL>
<p>
<H3>Examples of Type Testing</H3>
<p>
Using the example classes developed earlier, the following type tests all print 'true':
<p>
<DL>
<dt><dd><pre class="code">


<span class="library">print</span>( istype(MetaBaseClass(), MetaBaseClass) )

<span class="library">print</span>( istype(MetaChildClass(), MetaBaseClass) )

<span class="library">print</span>( istype(MetaChildClass(), MetaChildClass) )

<span class="library">print</span>( <span class="keyword">not</span> istype(MetaBaseClass(), MetaChildClass) )

<span class="library">print</span>( istype(MetaChildClass(), MetaBaseClass() ) )

<span class="library">print</span>( <span class="keyword">not</span> istype(MetaBaseClass(), MetaChildClass() ) )

<span class="library">print</span>( istype(MetaBaseClass(), <span class="string">'table'</span>) )

<span class="library">print</span>( <span class="keyword">not</span> istype(MetaBaseClass(), <span class="string">'rawtable'</span>) )

<span class="library">print</span>( istype({}, <span class="string">'rawtable'</span>) )

<span class="library">print</span>( istype(ProtoBaseClass(), ProtoBaseClass) )

<span class="library">print</span>( <span class="keyword">not</span> istype(ProtoAggregateClass(), MetaBaseClass) )

<span class="library">print</span>( istype(ProtoAggregateClass(), ProtoAggregateClass) )

<span class="library">print</span>( istype(ProtoAggregateClass(), ProtoBaseClass) )

<span class="library">print</span>( istype(FunctionClass(), FunctionClass) )

<span class="library">print</span>( istype(FunctionClass(), <span class="string">'function'</span>) )

<span class="library">print</span>( <span class="keyword">not</span> istype(FunctionClass(), <span class="string">'table'</span>) )

<span class="library">print</span>( istype(FunctionClass(), <span class="string">'callable'</span>) )

<span class="library">print</span>( istype(FunctionClass(), <span class="string">'object'</span>) )

<span class="library">print</span>( <span class="keyword">not</span> istype(FunctionClass(), <span class="string">'class'</span>) )

<span class="library">print</span>( istype(FunctionClass, <span class="string">'class'</span>) )

<span class="library">print</span>( istype(FunctionClass, <span class="string">'object'</span>) )

<span class="library">print</span>( istype(12, <span class="string">'number'</span>) )



</pre>

</DL>
<p>
<H3>Interworking with 'C'</H3>
<p>
For an example of a hybrid implementation of these ideas partly in 'C' and partly in Lua, check out the files <code>LibClass.h</code>; <code>LibClass.cpp</code> and <code>LibClass.lua</code> here:
<p>
<a href="https://github.com/JohnHind/Winsh.lua/tree/master/Winsh/Libraries">https://github.com/JohnHind/Winsh.lua/tree/master/Winsh/Libraries</a>
<p>
In particular, the implementation of the List class in these files starts off in 'C' and is subsequently completed in Lua!
<p>
<H3>Conclusion</H3>
<p>
By being prescriptive about the implementation of the concept of 'class', and by implementing a highly flexible type matching architecture, we can afford to be much looser about the implementation of objects. Different classes in the same Lua state can implement their objects in many different ways and still maintain a homogeneous type system in which the type of any value can be matched and characterised by a generic predicate function.
<p>
Implementing classes as function closures such that the function enclosed is the factory function or constructor for objects of that class brings big advantages. Notably classes defined in this way can be self contained and first class Lua values which do not depend on registry or global resources and are independent of storage. This approach also leverages the syntax shortcut provided for named function parameters to provide a syntax for collection class constructors which seems like a natural extension of Lua table constructors.
<p>
<a href="../wiki/JohnHind.html" >JohnHind</a> (13 February 2014)
<hr>
<a href="../wiki/RecentChanges.html" >RecentChanges</a> &middot; <a href="/cgi-bin/wiki.pl?action=editprefs" >preferences</a><br>
<a href="/cgi-bin/wiki.pl?action=edit&amp;id=ClassesAsConstructorClosures" >edit</a> &middot; <a href="/cgi-bin/wiki.pl?action=history&amp;id=ClassesAsConstructorClosures" >history</a><br>Last edited February 24, 2014 11:03 am GMT <a href="/cgi-bin/wiki.pl?action=browse&amp;diff=1&amp;id=ClassesAsConstructorClosures" >(diff)</a>
</body>
</html>