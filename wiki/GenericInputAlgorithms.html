<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>lua-users wiki: Generic Input Algorithms</TITLE>
<LINK TYPE="text/css" REL="stylesheet" HREF="../styles/main.css">
</HEAD>
<BODY ><table width="100%" border="0"> <tr><td align=left width="100%"><h1><a href="/cgi-bin/wiki.pl?action=search&amp;string=GenericInputAlgorithms&amp;body=1" title="List pages referring to GenericInputAlgorithms">Generic Input Algorithms</a></h1></td><td align=right>
    <table cellpadding="0" cellspacing="0" border="0" width="1%">
      <tbody>
        <tr>
            <td><a href="../index.html">
            <img src="../images/nav-logo.png" alt="lua-users home" width="177" height="40" border="0"></a></td>
        </tr>
        <tr>
            <td>
            <table cellpadding="0" cellspacing="0" border="0" width="100%">
                <tbody>
                <tr>
                    <td><img src="../images/nav-elbow.png" alt="" width="48" height="40"></td>
                    <td nowrap valign="middle" width="100%">
                        <a href="../wiki/index.html" class="nav">wiki</a></td>
                </tr>
                </tbody>
            </table>
            </td>
        </tr>
      </tbody>
    </table>
<form method="post" action="../wiki/FindPage.html" enctype="application/x-www-form-urlencoded" style="display:inline; margin:0;">
<input type="hidden" name="action" value="search"  /><input type="text" name="string"  size="20" style="" id="search_query1" /><input type="hidden" name="title" value="1"  /><input type="submit" name=".submit" value="Search" /><input type="hidden" name="body" value="on"  /></form></td></tr> </table>
<br clear=all>
<H3>Generic Functions and Algorithms in Lua</H3>
This describes the facilities of the <code>func</code> library, which was designed to make working with input more intuitive.  The source can be found at <a href="/files/wiki_insecure/func.lua">Files:wiki_insecure/func.lua</a>.
<p>
There are two special input iterators, <code>numbers()</code> and <code>words()</code>, which work like the very useful <code>io.lines()</code> iterator. To print all words found in the standard input:
<DL>
<dt><dd><pre class="code">
<span class="comment">-- words.lua</span>

<span class="library">require</span> <span class="string">'func'</span>

<span class="keyword">for</span> w <span class="keyword">in</span> words() <span class="keyword">do</span>

  <span class="library">print</span>(w)

<span class="keyword">end</span>

</pre>

</DL>
To test this out on some text, you would say at the OS command prompt:
<DL>
<dt><dd><pre>

$ lua words.lua &lt; test.txt

</pre>
</DL>
Printing out the values generated by an iterator is a very common operation, so <code>func</code> supplies the very convenient function <code>printall()</code>. It writes out all members of a <em>sequence</em> to standard output. By default, it puts out 7 items per line, separated by spaces, but you can optionally change these. In this case we do want each value on its own line:
<DL>
<dt><dd><pre class="code">
printall(words(),<span class="string">'\n'</span>)

</pre>

</DL>
<code>numbers()</code> creates a sequence of all numbers found in its input. For example, to sum all input numbers:
<DL>
<dt><dd><pre class="code">
<span class="library">require</span> <span class="string">'func'</span>

<span class="keyword">local</span> s 

<span class="keyword">for</span> x <span class="keyword">in</span> numbers() <span class="keyword">do</span>

  s = s + x

<span class="keyword">end</span>

<span class="library">print</span>(s)

</pre>

</DL>
Summation is a common operation when analyzing data so <code>func</code> defines a generic <code>sum()</code> function.  It returns the sum and the number of fields, so it's easy to calculate the average.
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> s,n = sum(numbers())

<span class="library">print</span>(<span class="string">'average value ='</span>,s/n)

</pre>

</DL>
Note that these iterators look for the appropriate patterns, so they don't depend on words or numbers being separated by spaces.  <code>numbers()</code> will find everything that looks like a number in a file, and will safely ignore anything else. So it's useful for heavily commented data or output files.
These iterators take an optional extra parameter, which can be a file or a string. For example, to print the sum and number of items in a file passed as a command-line parameter:
<DL>
<dt><dd><pre class="code">
f = <span class="library">io.open</span>(arg[1])

<span class="library">print</span>(sum(numbers(f)))

f:close()

</pre>

</DL>
It is useful to collect the output of an iterator as a table. Since it's so straightforward and instructive, here is a simplified definition of <code>copy()</code>:
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> copy(iter)

  <span class="keyword">local</span> res = {}

  <span class="keyword">local</span> k = 1

  <span class="keyword">for</span> v <span class="keyword">in</span> iter <span class="keyword">do</span>

     res[k] = v

     k = k + 1

  <span class="keyword">end</span>

  <span class="keyword">return</span> res

<span class="keyword">end</span>

</pre>

</DL>
The next example makes an array of all the numbers found in a string. Obviously this is a trivial case, but it's common to have to extract numbers from strings, which can be tricky. In particular, this makes sure that they actually get converted - I've been bit more than once by the simple fact that arr['1'] and arr[1] are not the same! 
<DL>
<dt><dd><pre class="code">
t = copy(numbers <span class="string">'10 20 30'</span>) <span class="comment">-- will be {10,20,30}</span>

s = sum(list(t))             <span class="comment">-- will be 60</span>

</pre>

</DL>
Note the table sequence adaptor <code>list()</code>, which allows tables to be used as sequences. It's common to operate on arrays with these functions, so if you do pass them a table <code>list()</code> will automatically be assumed. To print out an array of numbers in a particular format, one can use something like <code>printall(t,' ',5,'%7.3f')</code> to format them nicely.
Here's an implementation of the system command sort, that uses the <code>printall()</code> function to output each value of a sequence. I can't simply say <code>table.foreach(t,print)</code>, because that operation passes both the index and the value, so I would in effect get line numbers as well!
<DL>
<dt><dd><pre class="code">
t = copy(<span class="library">io.lines</span>())

<span class="library">table.sort</span>(t)

printall(t,<span class="string">'\n'</span>)   <span class="comment">-- try table.foreach(t,print) and see!</span>

</pre>

</DL>
Using the <code>sort()</code> function this becomes a one-liner:
<DL>
<dt><dd><pre class="code">
printall(sort(<span class="library">io.lines</span>()),<span class="string">'\n'</span>)

</pre>

</DL>
You can iterate over part of a sequence with <code>slice()</code>. This is passed an iterator, a start index, and an item count.  For example, this is a simple version of the <code>head</code> command;  it shows the first ten lines of its input.
<DL>
<dt><dd><pre class="code">
printall(slice(<span class="library">io.lines</span>(),1,10),<span class="string">'\n'</span>)

</pre>

</DL>
Sometimes we just want to count a sequence; for example this is a complete script that counts all the words in a file:
<DL>
<dt><dd><pre class="code">
<span class="library">require</span> <span class="string">'func'</span>

<span class="library">print</span>(count(words()))

</pre>

</DL>
In this form, <code>count()</code> is not so useful. But it can be given a function to select the items to be counted. For example, this gives me a rough idea of how many public functions there are in a Lua file. (If I didn't tie the match down to the begining, it would pick up local and anonymous functions as well)
<DL>
<dt><dd><pre class="code">
<span class="library">require</span> <span class="string">'func'</span>

<span class="library">print</span>(count(<span class="library">io.lines</span>(),matching <span class="string">'^%s*function'</span>))

</pre>

</DL>
where <code>matching()</code> is the following simple function. It creates a closure (a function bound to a local context) which is called for each item in the sequence:
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> matching(s)

  <span class="keyword">local</span> strfind = <span class="library">string.find</span>

  <span class="keyword">return</span> <span class="keyword">function</span>(v)

    <span class="keyword">return</span> strfind(v,s)

  <span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
<p>
You can of course use <em>any</em> sequence in these operations.  If you have the very useful lfs (Lua File System) library loaded, then <code>t = copy_if(lfs.dir(path),matching '%.cpp$')</code> will fill a list with all files with extension <code>.cpp</code> from <code>path</code>.
<p>
Another useful way to modify <code>count()</code>'s input is to use <code>unique()</code>
<DL>
<dt><dd><pre class="code">
<span class="comment">-- number of unique words in a file</span>

<span class="library">print</span>(count(unique(words())))

</pre>

</DL>
<code>unique()</code> is not implemented in the usual way, which requires the sequence to be first sorted. Instead, it uses <code>count_map()</code> to create a map where the keys are the items and the values are the counts. The rest is easy once we have <code>keys()</code>, which is the complementary brother of <code>list()</code>:
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> unique(iter)

  <span class="keyword">local</span> t = count_map(iter)

  <span class="keyword">return</span> keys(t)

<span class="keyword">end</span>

</pre>

</DL>
The classic 'count occurances of words in a file' is:
<DL>
<dt><dd><pre class="code">
<span class="library">table.foreach</span>(count_map(words()),<span class="library">print</span>)

</pre>

</DL>
When comparing two sequences, it's useful to <code>join()</code> them together. This will print out the differences between two files:
<DL>
<dt><dd><pre class="code">
<span class="keyword">for</span> x,y <span class="keyword">in</span> join(numbers(f1),numbers(f2)) <span class="keyword">do</span>

  <span class="library">print</span>(x-y)

<span class="keyword">end</span>

</pre>

</DL>
<H3>An AWK programming style in Lua</H3>
Before I discovered Lua, AWK was my favourite language for manipulating text files. (I even managed to convert some colleagues using the slogan 'AWK is the command-line equivalent of Excel'.) To give you a taste, here is a complete AWK program to print out the first and third columns of a file, scaling using the fourth column - note that the loop over all lines is implicit:
<DL>
<dt><dd><pre>

{ print $1/$4, $3/$4 }

</pre>
</DL>
The <code>func</code> library supplies the iterator <code>fields()</code> for this purpose.  Here is the equivalent Lua code:
<DL>
<dt><dd><pre class="code">
<span class="keyword">for</span> x,y,z <span class="keyword">in</span> fields{1,3,4} <span class="keyword">do</span>

   <span class="library">print</span>(x/z,y/z)

<span class="keyword">end</span>

</pre>

</DL>
Here is my current favourite one-liner. It counts how many values in the 7th column are greater than 44000, and is about half the speed of the equivalent AWK program (run using MAWK). That's not bad, considering how optimized AWK is for its specialized task! 
<DL>
<dt><dd><pre class="code">
<span class="library">print</span>(count(fields{7},greater_than(44000)))

</pre>

<dt><dd><pre>

{ if ($7 &gt; 44000) k++ } END { print(k) }

</pre>
</DL>
<code>fields()</code> can work with any input delimiter. This reads a set of values from a comma-separated file - note that passing n instead of a list of field ids is equivalent to {1,2,...n}:
<DL>
<dt><dd><pre class="code">
<span class="keyword">for</span> x,y <span class="keyword">in</span> fields({1,2},<span class="string">','</span>,f) <span class="keyword">do</span> ...

</pre>

<dt><dd><pre class="code">
<span class="keyword">for</span> x,y <span class="keyword">in</span> fields(2,<span class="string">','</span>,f) <span class="keyword">do</span> ...  <span class="comment">--equivalent--</span>

</pre>

</DL>
<H3>Efficiency in performance and expression</H3>
I think it's clear that common operations can be very concisely expressed using this generic programming style, but there are two reservations people tend to have at this point, certainly from my C++ experience with the STL.
The first objection is that the functional style is more inefficient. That's certainly true in theory, but how inefficient in practice?  For instance, here is a transcript of using the sequence <code>random()</code> to create a table with random values:
<DL>
<dt><dd><pre>

&gt; tt = copy(random(10000))

&gt; = sum(tt)

5039.542771691  10000

</pre>
</DL>
These operations happen pretty instantaneously on my elderly laptop, and I'm only starting to notice at 1e5 items. For 1e6 items, the first operation takes 2.14 seconds, compared to 2.08 seconds for the explicit loop! That goes down to 1.92 if I'm careful to use locals, so the optimal explicit version is:
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> t = {}

<span class="keyword">local</span> random = <span class="library">math.random</span>

<span class="keyword">for</span> i = 1,1e6 <span class="keyword">do</span>

   t[i] = random()

<span class="keyword">end</span>

</pre>

</DL>
This case shows that there's no compelling speed advantage to doing it the long way.  (I chose this example precisely because it doesn't involve file i/o, which tends to dominate the <code>words()</code> and <code>numbers()</code> run-times.)  The advantage is that there is less code to go wrong; the generic programming people believe that explicit loops are "tedious and error-prone", as Stroustrup says. 
<p>
The second objection is that it leads to weird and unnatural code.  This can certainly be the case in C++, which (let's face it) is not really suited to the functional style; there are no closures, and rigid static typing constantly gets in the way, requiring everything to be templates. The style suits Lua much better - doing this in C++ would not be half as readable, even using the Boost Lambda library:
<DL>
<dt><dd><pre class="code">
<span class="comment">-- sum of squares of input data using an internal iterator</span>

for_each(numbers(),<span class="keyword">function</span>(v)

    s = s + v*v

<span class="keyword">end</span>)

</pre>

<dt><dd><pre class="code">
<span class="comment">-- sum of squares of input data using an external iterator</span>

<span class="keyword">for</span> v <span class="keyword">in</span> numbers() <span class="keyword">do</span>

    s = s + v*v

<span class="keyword">end</span>

</pre>

</DL>
The idea is not to replace <em>all</em> loops, just the common generic patterns. Such code becomes easier to read, because any explicit loops will stand out more. Lua is particularly suited to this style, which often seems forced in C++.
<H3>Writing Custom Input Objects</H3>
If <code>f</code> is not a string, then <code>words(f)</code> will use the file object <code>f</code>. In fact, <code>f</code> can be any object which has a <code>read</code> method. All that the code assumes is that <code>f:read()</code> will return the next line of input text. Here is a more involved example, where I've created a class <code>Files</code> which allows us to read from a list of files. The obvious application is to mimic AWK's behaviour, where every file on the command-line becomes part of standard input.
<DL>
<dt><dd><pre class="code">
Files = {}

 

<span class="keyword">function</span> Files.create(list)

   <span class="keyword">local</span> files = {}

   files.list = {}

   <span class="keyword">local</span> n = <span class="library">table.getn</span>(list)

   <span class="keyword">for</span> i = 1,n <span class="keyword">do</span>

      files.list[i] = list[i]

   <span class="keyword">end</span>

   files.open_next = Files.open_next

   files.read = Files.read

   files:open_next()

   <span class="keyword">return</span> files

<span class="keyword">end</span>

 

<span class="keyword">function</span> Files:open_next()

   <span class="keyword">if</span> self.f <span class="keyword">then</span> self.f:close() <span class="keyword">end</span>

   <span class="keyword">local</span> nf = <span class="library">table.remove</span>(self.list,1)

   <span class="keyword">if</span> nf <span class="keyword">then</span>

      self.f = <span class="library">io.open</span>(nf)

      <span class="keyword">return</span> <span class="keyword">true</span>

   <span class="keyword">else</span>

      self.f = <span class="keyword">nil</span>

      <span class="keyword">return</span> <span class="keyword">false</span>

   <span class="keyword">end</span>

<span class="keyword">end</span>

 

<span class="keyword">function</span> Files:read()

  <span class="keyword">local</span> ret = self.f:read()

  <span class="keyword">if</span> <span class="keyword">not</span> ret <span class="keyword">then</span>

     <span class="keyword">if</span> <span class="keyword">not</span> self:open_next() <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span>

     <span class="keyword">return</span> self.f:read()

  <span class="keyword">else</span>

     <span class="keyword">return</span> ret

  <span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
I need to explain an apparent inconsistency. After praising the joys of loopless programming, there's a classic copy-table loop in <code>Files.create()</code>.  Lua programs are passed a global table called <code>arg</code>, which has the command-line arguments, <code>arg[1]</code>,<code>arg[2]</code>, etc.  But there's also <code>arg[0]</code>, the <em>script</em> name, and <code>arg[-1]</code> the actual program name.  The explicit loop in question is to make quite sure we don't copy those fields!
<DL>
<dt><dd><pre class="code">
files = Files.create(arg)

printall(words(files))

</pre>

</DL>
<H3>Notes on Implementation and Further Development</H3>
Most of <code>func</code> is a straightforward variation on the same theme; iterators and functions as closures.  Section 7.1 of PiL [ref?] explains the issues well, and I've used the <code>allwords</code> example as the basis for <code>words()</code> and <code>numbers()</code>. <code>fields()</code> was first implemented in a naive way, grabbing each field in turn, but later was implemented as one call to <code>string.find()</code>, by creating a custom regular expression.  For example, if fields 1 and 3 are needed, separated by commas, then the regexp looks like this - fields are defined as anything which is <em>not</em> a comma, and we capture using () the required fields.
<DL>
<dt><dd><pre>

'%s*([^,]+),[^,]+,([^,])'

</pre>
</DL>
The concept of <em>sequences</em> is very general, which means that it's easy to use the <code>func</code> operations with any library which provides an iterator. And that often simplifies code tremendously. For instance, here is how it can be with luasql. Consider the canonical way to access all rows of a query result:
<DL>
<dt><dd><pre class="code">
cur = con:execute <span class="string">'SELECT * FROM [Event Summaries]'</span>

mag = -9

row = cur:fetch({},<span class="string">'a'</span>)

<span class="keyword">while</span> row <span class="keyword">do</span>

  <span class="keyword">if</span> row.Magnitude &gt; mag <span class="keyword">then</span> 

     mag = row.Magnitude

  <span class="keyword">end</span>

  row = cur:fetch(row,<span class="string">'n'</span>)

<span class="keyword">end</span>

cur:close()

</pre>

</DL>
<p>
I can simply this by creating an iterator which keeps track of <code>row</code>:
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> rows(cursor)

  <span class="keyword">local</span> row = {}

  <span class="keyword">return</span> <span class="keyword">function</span>()

    <span class="keyword">return</span> cursor:fetch(row,<span class="string">'a'</span>)

  <span class="keyword">end</span>

<span class="keyword">end</span>



<span class="keyword">for</span> row <span class="keyword">in</span> rows(cur) <span class="keyword">do</span>

   <span class="keyword">if</span> row.Magnitude &gt; mag <span class="keyword">then</span> 

      mag = row.Magnitude    

   <span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
That's already a better loop, since we don't have to call <code>cursor:fetch</code> twice and look after a local <code>row</code>. We can also implement an equivalent to <code>fields</code>:
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> column(fieldname,cursor)

  <span class="keyword">local</span> row = {}

  <span class="keyword">return</span> <span class="keyword">function</span>()

    row = cur:fetch(row,<span class="string">'a'</span>)

    <span class="keyword">if</span> <span class="keyword">not</span> row <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span> 

    <span class="keyword">else</span> <span class="keyword">return</span> row[fieldname]

    <span class="keyword">end</span>

  <span class="keyword">end</span>

<span class="keyword">end</span>



<span class="keyword">local</span> minm,maxm = minmax(column(<span class="string">'Magnitude'</span>,cur))

</pre>

</DL>
There's no longer any explicit loops!  It is of course often more efficient to use SQL WHERE clauses to constrain the sequence.  The following works, but isn't the optimal way to do the job:
<DL>
<dt><dd><pre class="code">
<span class="library">print</span>(count(column(<span class="string">'Magnitude'</span>,cur),greater_than(2)))

</pre>

</DL>
<p>
-- <a href="../wiki/SteveDonovan.html" >SteveDonovan</a> 
<hr>
<a href="../wiki/RecentChanges.html" >RecentChanges</a> &middot; <a href="/cgi-bin/wiki.pl?action=editprefs" >preferences</a><br>
<a href="/cgi-bin/wiki.pl?action=edit&amp;id=GenericInputAlgorithms" >edit</a> &middot; <a href="/cgi-bin/wiki.pl?action=history&amp;id=GenericInputAlgorithms" >history</a><br>Last edited July 21, 2007 5:49 pm GMT <a href="/cgi-bin/wiki.pl?action=browse&amp;diff=1&amp;id=GenericInputAlgorithms" >(diff)</a>
</body>
</html>