<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>lua-users wiki: Vararg The Second Class Citizen</TITLE>
<LINK TYPE="text/css" REL="stylesheet" HREF="../styles/main.css">
</HEAD>
<BODY ><table width="100%" border="0"> <tr><td align=left width="100%"><h1><a href="/cgi-bin/wiki.pl?action=search&amp;string=VarargTheSecondClassCitizen&amp;body=1" title="List pages referring to VarargTheSecondClassCitizen">Vararg The Second Class Citizen</a></h1></td><td align=right>
    <table cellpadding="0" cellspacing="0" border="0" width="1%">
      <tbody>
        <tr>
            <td><a href="../index.html">
            <img src="../images/nav-logo.png" alt="lua-users home" width="177" height="40" border="0"></a></td>
        </tr>
        <tr>
            <td>
            <table cellpadding="0" cellspacing="0" border="0" width="100%">
                <tbody>
                <tr>
                    <td><img src="../images/nav-elbow.png" alt="" width="48" height="40"></td>
                    <td nowrap valign="middle" width="100%">
                        <a href="../wiki/index.html" class="nav">wiki</a></td>
                </tr>
                </tbody>
            </table>
            </td>
        </tr>
      </tbody>
    </table>
<form method="post" action="../wiki/FindPage.html" enctype="application/x-www-form-urlencoded" style="display:inline; margin:0;">
<input type="hidden" name="action" value="search"  /><input type="text" name="string"  size="20" style="" id="search_query1" /><input type="hidden" name="title" value="1"  /><input type="submit" name=".submit" value="Search" /><input type="hidden" name="body" value="on"  /></form></td></tr> </table>
<br clear=all>
Lua varargs "<code>...</code>" <a href="http://www.lua.org/manual/5.1/manual.html#2.5.9">[1]</a> are not <a href="http://en.wikipedia.org/wiki/First-class_object.html">[first class]</a> objects in Lua 5.1, and this leads to some limitations in expression.  Some of these issues and their workarounds are given here.
<p>
<UL>
<li> Issue #1: Vararg Saving
<li> Issue #2: Combining Lists
<li> Issue #3: Selecting the First N Elements in List
<li> Issue #4: Appending One Element to a List
<li> Issue #5: Reversing a List
<li> Issue #6: The map Function
<li> Issue #7: The filter Function
<li> Issue #8: Iterating over Varargs
</UL>
<p>
<H2>Issue #1: Vararg Saving</H2>
<p>
Lua 5.1 vararg (<code>...</code>) handling is a bit limited.  For example, it doesn't permit things like this:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> tuple(...) <span class="keyword">return</span> <span class="keyword">function</span>() <span class="keyword">return</span> ... <span class="keyword">end</span> <span class="keyword">end</span>

<span class="comment">--Gives error "cannot use '...' outside a vararg function near '...'"</span>

</pre>

</DL>
<p>
(Some comments on that are in <a href="/lists/lua-l/2007-03/msg00249.html">LuaList:2007-03/msg00249.html</a> .)
<p>
You might want to use such a function to temporarily store away the return values of a function call, do some other work, and then retrieve those stored return values again.  The following function would use this hypothetical <code>tuple</code> function to add trace statements around a given function:
<p>
<DL>
<dt><dd><pre class="code">
<span class="comment">--Wraps a function with trace statements.</span>

<span class="keyword">function</span> trace(f)

  <span class="keyword">return</span> <span class="keyword">function</span>(...)

    <span class="library">print</span>(<span class="string">"begin"</span>, f)

    <span class="keyword">local</span> result = tuple(f(...))

    <span class="library">print</span>(<span class="string">"end"</span>, f)

    <span class="keyword">return</span> result()

  <span class="keyword">end</span>

<span class="keyword">end</span>



test = trace(<span class="keyword">function</span>(x,y,z) <span class="library">print</span>(<span class="string">"calc"</span>, x,y,z); <span class="keyword">return</span> x+y, z <span class="keyword">end</span>)

<span class="library">print</span>(<span class="string">"returns:"</span>, test(2,3,<span class="keyword">nil</span>))

<span class="comment">-- Desired Output:</span>

<span class="comment">--   begin   function: 0x687350</span>

<span class="comment">--   calc    2       3       nil</span>

<span class="comment">--   end     function: 0x687350</span>

<span class="comment">--   returns:        5       nil</span>

</pre>

</DL>
<p>
Still, there are ways to achieve this in Lua.
<p>
<H3>Solution: <code> {...} </code> and <code>unpack</code></H3>
<p>
You could instead implement <code>trace</code> with the table construct <code> {...} </code> and <code>unpack</code>:
<p>
<DL>
<dt><dd><pre class="code">
<span class="comment">--Wraps a function with trace statements.</span>

<span class="keyword">function</span> trace(f)

  <span class="keyword">return</span> <span class="keyword">function</span>(...)

    <span class="library">print</span>(<span class="string">"begin"</span>, f)

    <span class="keyword">local</span> result = {f(...)}

    <span class="library">print</span>(<span class="string">"end"</span>, f)

    <span class="keyword">return</span> <span class="library">unpack</span>(result)

  <span class="keyword">end</span>

<span class="keyword">end</span>



test = trace(<span class="keyword">function</span>(x,y,z) <span class="library">print</span>(<span class="string">"calc"</span>, x,y,z); <span class="keyword">return</span> x+y, z <span class="keyword">end</span>)

<span class="library">print</span>(<span class="string">"returns:"</span>, test(2,3,<span class="keyword">nil</span>))

<span class="comment">-- Output:</span>

<span class="comment">--   begin   function: 0x6869d0</span>

<span class="comment">--   calc    2       3       nil</span>

<span class="comment">--   end     function: 0x6869d0</span>

<span class="comment">--   returns:        5</span>

</pre>

</DL>
<p>
Unfortunately, it misses a <code>nil</code> return value since <code>nil</code> are not explicitly storable in tables , and particularly <code> {...} </code> does not preserve information about trailing <code>nil</code>s (this is further discussed in <a href="../wiki/StoringNilsInTables.html" >StoringNilsInTables</a>).
<p>
<H3>Solution: <code> {...} </code> and <code>unpack</code> with <code>n</code></H3>
<p>
The following improvement on the previous solution properly handles <code>nil</code>s:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> pack2(...) <span class="keyword">return</span> {n=<span class="library">select</span>(<span class="string">'#'</span>, ...), ...} <span class="keyword">end</span>

<span class="keyword">function</span> unpack2(t) <span class="keyword">return</span> <span class="library">unpack</span>(t, 1, t.n) <span class="keyword">end</span>



<span class="comment">--Wraps a function with trace statements.</span>

<span class="keyword">function</span> trace(f)

  <span class="keyword">return</span> <span class="keyword">function</span>(...)

    <span class="library">print</span>(<span class="string">"begin"</span>, f)

    <span class="keyword">local</span> result = pack2(f(...))

    <span class="library">print</span>(<span class="string">"end"</span>, f)

    <span class="keyword">return</span> unpack2(result);

  <span class="keyword">end</span>

<span class="keyword">end</span>



test = trace(<span class="keyword">function</span>(x,y,z) <span class="library">print</span>(<span class="string">"calc"</span>, x,y,z); <span class="keyword">return</span> x+y, z <span class="keyword">end</span>)

<span class="library">print</span>(<span class="string">"returns:"</span>, test(2,3,<span class="keyword">nil</span>))

<span class="comment">-- Output:</span>

<span class="comment">--   begin   function: 0x6869d0</span>

<span class="comment">--   calc    2       3       nil</span>

<span class="comment">--   end     function: 0x6869d0</span>

<span class="comment">--   returns:        5       nil</span>

</pre>

</DL>
<p>
A variant noted by Shirik is
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> tuple(...)

  <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

  <span class="keyword">local</span> t = {...}

  <span class="keyword">return</span> <span class="keyword">function</span>() <span class="keyword">return</span> <span class="library">unpack</span>(t, 1, n) <span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
<p>
<H3>Solution: <code>nil</code> Placeholders</H3>
<p>
The following approach swaps the <code>nil</code>'s with placeholders that <em>can</em> be stored in tables.  It's probably less optimal here, but the approach might be usable elsewhere.
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> NIL = {} <span class="comment">-- placeholder value for nil, storable in table.</span>

<span class="keyword">function</span> pack2(...)

  <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

  <span class="keyword">local</span> t = {}

  <span class="keyword">for</span> i = 1,n <span class="keyword">do</span>

    <span class="keyword">local</span> v = <span class="library">select</span>(i, ...)

    t[i] = (v == <span class="keyword">nil</span>) <span class="keyword">and</span> NIL <span class="keyword">or</span> v

  <span class="keyword">end</span>

  <span class="keyword">return</span> t

<span class="keyword">end</span>



<span class="keyword">function</span> unpack2(t)  <span class="comment">--caution: modifies t</span>

  <span class="keyword">if</span> #t == 0 <span class="keyword">then</span>

    <span class="keyword">return</span>

  <span class="keyword">else</span>

    <span class="keyword">local</span> v = <span class="library">table.remove</span>(t, 1)

    <span class="keyword">if</span> v == NIL <span class="keyword">then</span> v = <span class="keyword">nil</span> <span class="keyword">end</span>

    <span class="keyword">return</span> v, unpack2(t)

  <span class="keyword">end</span>

<span class="keyword">end</span>



<span class="comment">--Wraps a function with trace statements.</span>

<span class="keyword">function</span> trace(f)

  <span class="keyword">return</span> <span class="keyword">function</span>(...)

    <span class="library">print</span>(<span class="string">"begin"</span>, f)

    <span class="keyword">local</span> result = pack2(f(...))

    <span class="library">print</span>(<span class="string">"end"</span>, f)

    <span class="keyword">return</span> unpack2(result)

  <span class="keyword">end</span>

<span class="keyword">end</span>



test = trace(<span class="keyword">function</span>(x,y,z) <span class="library">print</span>(<span class="string">"calc"</span>, x,y,z); <span class="keyword">return</span> x+y, z <span class="keyword">end</span>)

<span class="library">print</span>(<span class="string">"returns:"</span>, test(2,3,<span class="keyword">nil</span>))

<span class="comment">-- Output:</span>

<span class="comment">--   begin   function: 0x687350</span>

<span class="comment">--   calc    2       3       nil</span>

<span class="comment">--   end     function: 0x687350</span>

<span class="comment">--   returns:        5       nil</span>

</pre>

</DL>
<p>
Here are more optimal implementations of pack2 and unpack2:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> NIL = {} <span class="comment">-- placeholder value for nil, storable in table.</span>

<span class="keyword">function</span> pack2(...)

  <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

  <span class="keyword">local</span> t = {...}

  <span class="keyword">for</span> i = 1,n <span class="keyword">do</span>

    <span class="keyword">if</span> t[i] == <span class="keyword">nil</span> <span class="keyword">then</span>

      t[i] = NIL

    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="keyword">return</span> t

<span class="keyword">end</span>



<span class="keyword">function</span> unpack2(t, k, n)

  k = k <span class="keyword">or</span> 1

  n = n <span class="keyword">or</span> #t

  <span class="keyword">if</span> k &gt; n <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>

  <span class="keyword">local</span> v = t[k]

  <span class="keyword">if</span> v == NIL <span class="keyword">then</span> v = <span class="keyword">nil</span> <span class="keyword">end</span>

  <span class="keyword">return</span> v, unpack2(t, k + 1, n)

<span class="keyword">end</span>

</pre>

</DL>
As a good side effect, now unpack2 can operate on range of indexes [k, n] instead of whole table. If you don't specify the range, whole table is unpacked.--Sergey Rozhenko, 2009, Lua 5.1
<p>
See also <a href="../wiki/StoringNilsInTables.html" >StoringNilsInTables</a>.
<p>
<H3>Solution: Continuation Passing Style (CPS)</H3>
<p>
Tables can be avoided if we use the Continuation passing style (CPS) (<a href="http://en.wikipedia.org/wiki/Continuation_passing_style.html">[Wikipedia]</a>) as below.  We could expect this to be a bit more efficient.
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> trace(f)

  <span class="keyword">local</span> helper = <span class="keyword">function</span>(...)

    <span class="library">print</span>(<span class="string">"end"</span>, f)

    <span class="keyword">return</span> ...

  <span class="keyword">end</span>

  <span class="keyword">return</span> <span class="keyword">function</span>(...)

    <span class="library">print</span>(<span class="string">"begin"</span>, f)

    <span class="keyword">return</span> helper(f(...))

  <span class="keyword">end</span>

<span class="keyword">end</span>



test = trace(<span class="keyword">function</span>(x,y,z) <span class="library">print</span>(<span class="string">"calc"</span>, x,y,z); <span class="keyword">return</span> x+y, z <span class="keyword">end</span>)

<span class="library">print</span>(<span class="string">"returns:"</span>, test(2,3,<span class="keyword">nil</span>))

<span class="comment">-- Output:</span>

<span class="comment">--   begin   function: 0x686b10</span>

<span class="comment">--   calc    2       3       nil</span>

<span class="comment">--   end     function: 0x686b10</span>

<span class="comment">--   returns:        5       nil</span>

</pre>

</DL>
<p>
The CPS approach was also used in the <a href="../wiki/RiciLake.html" >RiciLake</a>'s string split function (<a href="/lists/lua-l/2006-12/msg00414.html">LuaList:2006-12/msg00414.html</a>).
<p>
<H3>Solution: Code Generation</H3>
<p>
Another approach is code generation, which compiles a separate constructor for each tuple size.  There is some initial overhead building the constructors, but the constructors themselves can be optimally implemented.  The <code>tuple</code> function used previously can be implemented as such:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> build_constructor(n)

  <span class="keyword">local</span> t = {}; <span class="keyword">for</span> i = 1,n <span class="keyword">do</span> t[i] = <span class="string">"a"</span> .. i <span class="keyword">end</span>

  <span class="keyword">local</span> arglist = <span class="library">table.concat</span>(t, <span class="string">','</span>)

  <span class="keyword">local</span> src = <span class="string">"return function("</span> .. arglist ..

              <span class="string">") return function() return "</span> .. arglist .. <span class="string">" end end"</span>

  <span class="keyword">return</span> <span class="library">assert</span>(<span class="library">loadstring</span>(src))()

<span class="keyword">end</span>

<span class="keyword">function</span> tuple(...)

  <span class="keyword">local</span> construct = build_constructor(<span class="library">select</span>(<span class="string">'#'</span>, ...))

  <span class="keyword">return</span> construct(...)

<span class="keyword">end</span>

</pre>

</DL>
<p>
To avoid the overhead of code generation on each store, we can memoize the <code>make_storeimpl</code> function (for background see <a href="http://en.wikipedia.org/wiki/Memoization.html">[Wikipedia:Memoization]</a> and <a href="../wiki/FuncTables.html" >FuncTables</a>).
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> Memoize(fn)

  <span class="keyword">return</span> <span class="library">setmetatable</span>({}, {

    __index = <span class="keyword">function</span>(t, k) <span class="keyword">local</span> val = fn(k); t[k] = val; <span class="keyword">return</span> val <span class="keyword">end</span>,

    __call  = <span class="keyword">function</span>(t, k) <span class="keyword">return</span> t[k] <span class="keyword">end</span>

  })

<span class="keyword">end</span>



build_constructor = Memoize(build_constructor)

</pre>

</DL>
<p>
A more complete example of tuples implemented via code generation is in <a href="../wiki/FunctionalTuples.html" >FunctionalTuples</a>.
<p>
The code building/memoization technique and the above <code>Memoize</code> function are based on some previous related examples by <a href="../wiki/RiciLake.html" >RiciLake</a> such as <a href="http://article.gmane.org/gmane.comp.lang.lua.general/36610">[Re: The Curry Challenge]</a>.
<p>
Note also that if your wrapped function raises exceptions, you would want to <code>pcall</code> as well (<a href="/lists/lua-l/2007-02/msg00165.html">LuaList:2007-02/msg00165.html</a>).
<p>
<H3>Solution: Functional, Recursive</H3>
<p>
The following approach is purely functional (no tables) and avoids code generation.  It's not necessarily the most efficient as it creates a function per tuple element.
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> helper(n, first, ...)

  <span class="keyword">if</span> n == 1 <span class="keyword">then</span>

    <span class="keyword">return</span> <span class="keyword">function</span>() <span class="keyword">return</span> first <span class="keyword">end</span>

  <span class="keyword">else</span>

    <span class="keyword">local</span> rest = helper(n-1, ...)

    <span class="keyword">return</span> <span class="keyword">function</span>() <span class="keyword">return</span> first, rest() <span class="keyword">end</span>

  <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> tuple(...)

  <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

  <span class="keyword">return</span> (n == 0) <span class="keyword">and</span> <span class="keyword">function</span>() <span class="keyword">end</span> <span class="keyword">or</span> helper(n, ...)

<span class="keyword">end</span>





<span class="comment">-- TEST</span>

<span class="keyword">local</span> <span class="keyword">function</span> join(...)

  <span class="keyword">local</span> t = {n=<span class="library">select</span>(<span class="string">'#'</span>, ...), ...}

  <span class="keyword">for</span> i=1,t.n <span class="keyword">do</span> t[i] = <span class="library">tostring</span>(t[i]) <span class="keyword">end</span>

  <span class="keyword">return</span> <span class="library">table.concat</span>(t, <span class="string">","</span>)

<span class="keyword">end</span>

<span class="keyword">local</span> t = tuple()

<span class="library">assert</span>(join(t()) == <span class="string">""</span>)

t = tuple(2,3,<span class="keyword">nil</span>,4,<span class="keyword">nil</span>)

<span class="library">assert</span>(join(t()) == <span class="string">"2,3,nil,4,nil"</span>)

<span class="library">print</span> <span class="string">"done"</span>

</pre>

</DL>
<p>
<H3>Solution: Coroutines</H3>
<p>
Another idea is with coroutines:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">do</span>

  <span class="keyword">local</span> <span class="keyword">function</span> helper(...)

    <span class="library">coroutine.yield</span>()

    <span class="keyword">return</span> ...

  <span class="keyword">end</span>

  <span class="keyword">function</span> pack2(...)

    <span class="keyword">local</span> o = <span class="library">coroutine.create</span>(helper)

    <span class="library">coroutine.resume</span>(o, ...)

    <span class="keyword">return</span> o

  <span class="keyword">end</span>

  <span class="keyword">function</span> unpack2(o)

    <span class="keyword">return</span> <span class="library">select</span>(2, <span class="library">coroutine.resume</span>(o))

  <span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
<p>
A similar suggestion was posted in <a href="/lists/lua-l/2007-02/msg00142.html">LuaList:2007-02/msg00142.html</a> .  That can be inefficient though (<a href="../wiki/RiciLake.html" >RiciLake</a> notes that a minimal coroutine occupies slightly more than 1k plus malloc overhead, on freebsd it totals close to 2k, and the largest part is the stack, which defaults to 45 slots @ 12 or 16 bytes each).
<p>
It is not necessary to create a new coroutine on each call.  The following approach is rather efficient, and the recursion uses a tail call:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> yield = <span class="library">coroutine.yield</span>

<span class="keyword">local</span> resume = <span class="library">coroutine.resume</span>

<span class="keyword">local</span> <span class="keyword">function</span> helper(...)

  yield(); <span class="keyword">return</span> helper(yield(...))

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> make_stack() <span class="keyword">return</span> <span class="library">coroutine.create</span>(helper) <span class="keyword">end</span>



<span class="comment">-- Example</span>

<span class="keyword">local</span> stack = make_stack()

<span class="keyword">local</span> <span class="keyword">function</span> trace(f)

  <span class="keyword">return</span> <span class="keyword">function</span>(...)

    <span class="library">print</span>(<span class="string">"begin"</span>, f)

    resume(stack, f(...))

    <span class="library">print</span>(<span class="string">"emd"</span>, f)

    <span class="keyword">return</span> <span class="library">select</span>(2, resume(stack))

  <span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
<p>
<H3>Solution: Upvalues in C Closure</H3>
<p>
Tuples can be implemented in C as a closure containing the tuple elements as upvalues.  This is demonstrated in Section 27.3 of <em>Programming In Lua, 2nd Ed</em> <a href="http://www.inf.puc-rio.br/~roberto/pil2/">[2]</a>.
<p>
<H3>Benchmarks</H3>
<p>
The speeds of the above solutions are compared in the following benchmark.
<p>
<DL>
<dt><dd><pre class="code">
<span class="comment">-- Avoid global table accesses in benchmark.</span>

<span class="keyword">local</span> time = <span class="library">os.time</span>

<span class="keyword">local</span> <span class="library">unpack</span> = <span class="library">unpack</span>

<span class="keyword">local</span> <span class="library">select</span> = <span class="library">select</span>



<span class="comment">-- Benchmarks function f using chunks of nbase iterations for duration</span>

<span class="comment">-- seconds in ntrials trials.</span>

<span class="keyword">local</span> <span class="keyword">function</span> bench(duration, nbase, ntrials, func, ...)

  <span class="library">assert</span>(nbase % 10 == 0)

  <span class="keyword">local</span> nloops = nbase/10

  <span class="keyword">local</span> ts = {}

  <span class="keyword">for</span> k=1,ntrials <span class="keyword">do</span>

    <span class="keyword">local</span> t1, t2 = time()

    <span class="keyword">local</span> nloops2 = 0

    <span class="keyword">repeat</span>

      <span class="keyword">for</span> j=1,nloops <span class="keyword">do</span>

        func(...) func(...) func(...) func(...) func(...)

        func(...) func(...) func(...) func(...) func(...)

      <span class="keyword">end</span>

      t2 = time()

      nloops2 = nloops2 + 1

   <span class="keyword">until</span> t2 - t1 &gt;= duration

    <span class="keyword">local</span> t = (t2-t1) / (nbase * nloops2)

    ts[k] = t

  <span class="keyword">end</span>

  <span class="keyword">return</span> <span class="library">unpack</span>(ts)

<span class="keyword">end</span>



<span class="keyword">local</span> <span class="keyword">function</span> print_bench(name, duration, nbase, ntrials, func, ...)

  <span class="keyword">local</span> fmt = (<span class="string">" %0.1e"</span>):rep(ntrials)

  <span class="library">print</span>(<span class="library">string.format</span>(<span class="string">"%25s:"</span> .. fmt, name,

                      bench(duration, nbase, ntrials, func, ...) ))

<span class="keyword">end</span>



<span class="comment">-- Test all methods.</span>

<span class="keyword">local</span> <span class="keyword">function</span> test_suite(duration, nbase, ntrials)

  <span class="library">print</span>(<span class="string">"name"</span> .. (<span class="string">", t"</span>):rep(ntrials) .. <span class="string">" (times in sec)"</span>)



  <span class="keyword">do</span> <span class="comment">-- This is a base-line.</span>

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...) <span class="keyword">return</span> f(...) <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"(control)"</span>, duration, nbase, ntrials, f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">local</span> <span class="keyword">function</span> helper(...)

        <span class="keyword">return</span> ...

      <span class="keyword">end</span>

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        <span class="keyword">return</span> helper(f(...))

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"CPS"</span>, duration, nbase, ntrials, f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>

    <span class="keyword">local</span> yield = <span class="library">coroutine.yield</span>

    <span class="keyword">local</span> resume = <span class="library">coroutine.resume</span>

    <span class="keyword">local</span> <span class="keyword">function</span> helper(...)

      yield(); <span class="keyword">return</span> helper(yield(...))

    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> make_stack() <span class="keyword">return</span> <span class="library">coroutine.create</span>(helper) <span class="keyword">end</span>

    <span class="keyword">local</span> stack = make_stack()

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        resume(stack, f(...))

        <span class="keyword">return</span> <span class="library">select</span>(2, resume(stack))

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"Coroutine"</span>, duration, nbase, ntrials, f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        <span class="keyword">local</span> t = {f(...)}

        <span class="keyword">return</span> <span class="library">unpack</span>(t)

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"{...} and unpack"</span>, duration, nbase, ntrials, f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>  

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

        <span class="keyword">local</span> t = {f(...)}

        <span class="keyword">return</span> <span class="library">unpack</span>(t, 1, n)

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"{...} and unpack with n"</span>, duration, nbase, ntrials,

                f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>

    <span class="keyword">local</span> NIL = {}

    <span class="keyword">local</span> <span class="keyword">function</span> pack2(...)

      <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

      <span class="keyword">local</span> t = {...}

      <span class="keyword">for</span> i=1,n <span class="keyword">do</span>

        <span class="keyword">local</span> v = t[i]

        <span class="keyword">if</span> t[i] == <span class="keyword">nil</span> <span class="keyword">then</span> t[i] = NIL <span class="keyword">end</span>

      <span class="keyword">end</span>

      <span class="keyword">return</span> t

    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> unpack2(t)

      <span class="keyword">local</span> n = #t

      <span class="keyword">for</span> i=1,n <span class="keyword">do</span>

        <span class="keyword">local</span> v = t[i]

        <span class="keyword">if</span> t[i] == NIL <span class="keyword">then</span> t[i] = <span class="keyword">nil</span> <span class="keyword">end</span>

      <span class="keyword">end</span>

      <span class="keyword">return</span> <span class="library">unpack</span>(t, 1, n)

    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        <span class="keyword">local</span> t = pack2(f(...))

        <span class="keyword">return</span> unpack2(t)

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"nil Placeholder"</span>, duration, nbase, ntrials,

                f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>

    <span class="comment">-- This is a simplified version of Code Generation for comparison.</span>

    <span class="keyword">local</span> <span class="keyword">function</span> tuple(a1,a2,a3,a4,a5)

      <span class="keyword">return</span> <span class="keyword">function</span>() <span class="keyword">return</span> a1,a2,a3,a4,a5 <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        <span class="keyword">local</span> t = tuple(f(...))

        <span class="keyword">return</span> t()

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"Closure"</span>, duration, nbase, ntrials, f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>

    <span class="keyword">local</span> <span class="keyword">function</span> build_constructor(n)

      <span class="keyword">local</span> t = {}; <span class="keyword">for</span> i = 1,n <span class="keyword">do</span> t[i] = <span class="string">"a"</span> .. i <span class="keyword">end</span>

      <span class="keyword">local</span> arglist = <span class="library">table.concat</span>(t, <span class="string">','</span>)

      <span class="keyword">local</span> src = <span class="string">"return function("</span> .. arglist ..

                  <span class="string">") return function() return "</span> .. arglist .. <span class="string">" end end"</span>

      <span class="keyword">return</span> <span class="library">assert</span>(<span class="library">loadstring</span>(src))()

    <span class="keyword">end</span>

    <span class="keyword">local</span> cache = {}

    <span class="keyword">local</span> <span class="keyword">function</span> tuple(...)

      <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

      <span class="keyword">local</span> construct = cache[n]

      <span class="keyword">if</span> <span class="keyword">not</span> construct <span class="keyword">then</span>

        construct = build_constructor(n)

        cache[n] = construct

      <span class="keyword">end</span>

      <span class="keyword">return</span> construct(...)

    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        <span class="keyword">local</span> t = tuple(f(...))

        <span class="keyword">return</span> t()

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"Code Generation"</span>, duration, nbase, ntrials,

                f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="keyword">do</span>

    <span class="keyword">local</span> <span class="keyword">function</span> helper(n, first, ...)

      <span class="keyword">if</span> n == 1 <span class="keyword">then</span>

        <span class="keyword">return</span> <span class="keyword">function</span>() <span class="keyword">return</span> first <span class="keyword">end</span>

      <span class="keyword">else</span>

        <span class="keyword">local</span> rest = helper(n-1, ...)

        <span class="keyword">return</span> <span class="keyword">function</span>() <span class="keyword">return</span> first, rest() <span class="keyword">end</span>

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> tuple(...)

      <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

      <span class="keyword">return</span> (n == 0) <span class="keyword">and</span> <span class="keyword">function</span>() <span class="keyword">end</span> <span class="keyword">or</span> helper(n, ...)

    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> trace(f)

      <span class="keyword">return</span> <span class="keyword">function</span>(...)

        <span class="keyword">local</span> t = tuple(f(...))

        <span class="keyword">return</span> t()

      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">local</span> f = trace(<span class="keyword">function</span>() <span class="keyword">return</span> 11,12,13,14,15 <span class="keyword">end</span>)

    print_bench(<span class="string">"Functional, Recursive"</span>, duration, nbase, ntrials,

                f, 1,2,3,4,5)

  <span class="keyword">end</span>



  <span class="comment">-- NOTE: Upvalues in C Closure not benchmarked here.</span>



  <span class="library">print</span> <span class="string">"done"</span>

<span class="keyword">end</span>



test_suite(10, 1000000, 3)

test_suite(10, 1000000, 1) <span class="comment">-- recheck</span>

</pre>

</DL>
<p>
Results:
<p>
<DL>
<dt><dd><pre>

(Pentium4/3GHz)

name, t, t, t (times in sec)

                (control): 3.8e-007 3.8e-007 4.0e-007

                      CPS: 5.6e-007 6.3e-007 5.9e-007

                Coroutine: 1.7e-006 1.7e-006 1.7e-006

         {...} and unpack: 2.2e-006 2.2e-006 2.4e-006

  {...} and unpack with n: 2.5e-006 2.5e-006 2.5e-006

          nil Placeholder: 5.0e-006 4.7e-006 4.7e-006

                  Closure: 5.0e-006 5.0e-006 5.0e-006

          Code Generation: 5.5e-006 5.5e-006 5.5e-006

    Functional, Recursive: 1.3e-005 1.3e-005 1.3e-005

done

</pre>
</DL>
<p>
The CPS is the fastest, followed by coroutines (both operated on the stack).  Tables take a bit more time than the coroutine approach, though coroutines could be even faster if we didn't have the the <code>select</code> on the <code>resume</code>.  Use of closures are a few times slower still (including when generalized with code generation) to an order of magnitude slower (if generalized with Functional, Recursive).
<p>
For a tuple size of 1, we get
<p>
<DL>
<dt><dd><pre>

name, t, t, t (times in sec)

                (control): 2.9e-007 2.8e-007 2.7e-007

                      CPS: 4.3e-007 4.3e-007 4.3e-007

                Coroutine: 1.4e-006 1.4e-006 1.4e-006

         {...} and unpack: 2.0e-006 2.2e-006 2.2e-006

  {...} and unpack with n: 2.4e-006 2.5e-006 2.4e-006

          nil Placeholder: 3.3e-006 3.3e-006 3.3e-006

                  Closure: 2.0e-006 2.0e-006 2.0e-006

          Code Generation: 2.2e-006 2.5e-006 2.2e-006

    Functional, Recursive: 2.5e-006 2.4e-006 2.2e-006

done

</pre>
</DL>
<p>
For a tuple size of 20, we get
<p>
<DL>
<dt><dd><pre class="code">
name, t, t, t (times <span class="keyword">in</span> sec)

                (control): 8.3e-007 9.1e-007 9.1e-007

                      CPS: 1.3e-006 1.3e-006 1.1e-006

                Coroutine: 2.7e-006 2.7e-006 2.7e-006

         {...} <span class="keyword">and</span> <span class="library">unpack</span>: 3.0e-006 3.2e-006 3.0e-006

  {...} <span class="keyword">and</span> <span class="library">unpack</span> with n: 3.7e-006 3.3e-006 3.7e-006

          <span class="keyword">nil</span> Placeholder: 1.0e-005 1.0e-005 1.0e-005

                  Closure: 1.8e-005 1.8e-005 1.8e-005

          Code Generation: 1.9e-005 1.8e-005 1.9e-005

    Functional, Recursive: 5.7e-005 5.7e-005 5.8e-005

done

</pre>

</DL>
<p>
Notice that the times for table construction methods differ relatively little with respect to tuple size (due to the initial overhead of constructing a table).  In contrast, use of closures entails run times that vary more significantly with tuple size.
<p>
<H2>Issue #2: Combining Lists</H2>
<p>
Problem: given two variable length lists (e.g. the return values of two functions, <code>f</code> and <code>g</code>, that each return multiple values), combine them into a single list.
<p>
This can be a problem because of the behavior of Lua to discard all but the first return value of a function unless it is the last item in a list:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> f() <span class="keyword">return</span> 1,2,3 <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> g() <span class="keyword">return</span> 4,5,6 <span class="keyword">end</span>

<span class="library">print</span>(f(), g()) <span class="comment">-- prints 1 4 5 6</span>

</pre>

</DL>
<p>
Besides the obvious solutions of converting the lists into objects such as tables (via the methods in Issue #1 above), there are ways to do this with only function calls.
<p>
<H3>Solution</H3>
<p>
The following combines lists recursively by prepending only one element at a time and delaying evaluation of one of the lists.
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> helper(f, n, a, ...)

  <span class="keyword">if</span> n == 0 <span class="keyword">then</span> <span class="keyword">return</span> f() <span class="keyword">end</span>

  <span class="keyword">return</span> a, helper(f, n-1, ...)

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> combine(f, ...)

  <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

  <span class="keyword">return</span> helper(f, n, ...)

<span class="keyword">end</span>



<span class="comment">-- TEST</span>

<span class="keyword">local</span> <span class="keyword">function</span> join(...)

  <span class="keyword">local</span> t = {n=<span class="library">select</span>(<span class="string">'#'</span>, ...), ...}

  <span class="keyword">for</span> i=1,t.n <span class="keyword">do</span> t[i] = <span class="library">tostring</span>(t[i]) <span class="keyword">end</span>

  <span class="keyword">return</span> <span class="library">table.concat</span>(t, <span class="string">","</span>)

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> f0() <span class="keyword">return</span> <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> f1() <span class="keyword">return</span> 1 <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> g1() <span class="keyword">return</span> 2 <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> f3() <span class="keyword">return</span> 1,2,3 <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> g3() <span class="keyword">return</span> 4,5,6 <span class="keyword">end</span>

<span class="library">assert</span>(join(combine(f0, f0())) == <span class="string">""</span>)

<span class="library">assert</span>(join(combine(f0, f1())) == <span class="string">"1"</span>)

<span class="library">assert</span>(join(combine(f1, f0())) == <span class="string">"1"</span>)

<span class="library">assert</span>(join(combine(g1, f1())) == <span class="string">"1,2"</span>)

<span class="library">assert</span>(join(combine(g3, f3())) == <span class="string">"1,2,3,4,5,6"</span>)

<span class="library">print</span> <span class="string">"done"</span>

</pre>

</DL>
<p>
<H2>Issue #3: Selecting the First N Elements in List</H2>
<p>
Problem: Return a list consisting of the first N elements in another list.
<p>
The <code>select</code> function allows selecting the last N elements in a list, but there is no built-in function for selecting the first N elements.
<p>
<H3>Solution</H3>
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> helper(n, a, ...)

  <span class="keyword">if</span> n == 0 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>

  <span class="keyword">return</span> a, helper(n-1, ...)

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> first(k, ...)

  <span class="keyword">local</span> n = <span class="library">select</span>(<span class="string">'#'</span>, ...)

  <span class="keyword">return</span> helper(k, ...)

<span class="keyword">end</span>



<span class="comment">-- TEST</span>

<span class="keyword">local</span> <span class="keyword">function</span> join(...)

  <span class="keyword">local</span> t = {n=<span class="library">select</span>(<span class="string">'#'</span>, ...), ...}

  <span class="keyword">for</span> i=1,t.n <span class="keyword">do</span> t[i] = <span class="library">tostring</span>(t[i]) <span class="keyword">end</span>

  <span class="keyword">return</span> <span class="library">table.concat</span>(t, <span class="string">","</span>)

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> f0() <span class="keyword">return</span> <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> f1() <span class="keyword">return</span> 1 <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> f8() <span class="keyword">return</span> 1,2,3,4,5,6,7,8 <span class="keyword">end</span>

<span class="library">assert</span>(join(first(0, f0())) == <span class="string">""</span>)

<span class="library">assert</span>(join(first(0, f1())) == <span class="string">""</span>)

<span class="library">assert</span>(join(first(1, f1())) == <span class="string">"1"</span>)

<span class="library">assert</span>(join(first(0, f8())) == <span class="string">""</span>)

<span class="library">assert</span>(join(first(1, f8())) == <span class="string">"1"</span>)

<span class="library">assert</span>(join(first(2, f8())) == <span class="string">"1,2"</span>)

<span class="library">assert</span>(join(first(8, f8())) == <span class="string">"1,2,3,4,5,6,7,8"</span>)

<span class="library">print</span> <span class="string">"done"</span>

</pre>

</DL>
<p>
Note: if the number of elements is fixed, the solution is easier:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> firstthree(a,b,c) <span class="keyword">return</span> a,b,c <span class="keyword">end</span>

<span class="library">assert</span>(join(firstthree(f8())) == <span class="string">"1,2,3"</span>)  <span class="comment">-- TEST</span>

</pre>

</DL>
<p>
Code generation approaches can be based on this.
<p>
<H2>Issue #4: Appending One Element to a List</H2>
<p>
Problem: Append one element to a list.
<p>
Note that prepending one element to a list is simple: <code> {a, ...} </code>
<p>
<H3>Solution</H3>
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> helper(a, n, b, ...)

  <span class="keyword">if</span>   n == 0 <span class="keyword">then</span> <span class="keyword">return</span> a

  <span class="keyword">else</span>             <span class="keyword">return</span> b, helper(a, n-1, ...) <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> append(a, ...)

  <span class="keyword">return</span> helper(a, <span class="library">select</span>(<span class="string">'#'</span>, ...), ...)

<span class="keyword">end</span>

</pre>

</DL>
<p>
Note: if the number of elements is fixed, the solution is easier:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> append3(e, a, b, c) <span class="keyword">return</span> a, b, c, e <span class="keyword">end</span>

</pre>

</DL>
<p>
<H2>Issue #5: Reversing a List</H2>
<p>
Problem: Reverse a list.
<p>
<H3>Solution</H3>
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> helper(n, a, ...)

  <span class="keyword">if</span> n &gt; 0 <span class="keyword">then</span> <span class="keyword">return</span> append(a, helper(n-1, ...)) <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> reverse(...)

  <span class="keyword">return</span> helper(<span class="library">select</span>(<span class="string">'#'</span>, ...), ...)

<span class="keyword">end</span>

</pre>

</DL>
<p>
Note: if the number of elements is fixed, the solution is easier:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> reverse3(a,b,c) <span class="keyword">return</span> b,c,a <span class="keyword">end</span>

</pre>

</DL>
<p>
<H2>Issue #6: The map Function</H2>
<p>
Problem: Implement the map <a href="http://en.wikipedia.org/wiki/Map_(higher-order_function).html">[3]</a> function over a list.
<p>
<H3>Solution</H3>
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> helper(f, n, a, ...)

  <span class="keyword">if</span> n &gt; 0 <span class="keyword">then</span> <span class="keyword">return</span> f(a), helper(f, n-1, ...) <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> map(f, ...)

  <span class="keyword">return</span> helper(f, <span class="library">select</span>(<span class="string">'#'</span>, ...), ...)

<span class="keyword">end</span>

</pre>

</DL>
<p>
<H2>Issue #7: The filter Function</H2>
<p>
Problem: Implement the filter <a href="http://en.wikipedia.org/wiki/Filter_(higher-order_function).html">[4]</a> function over a list.
<p>
<H3>Solution</H3>
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">local</span> <span class="keyword">function</span> helper(f, n, a, ...)

  <span class="keyword">if</span> n &gt; 0 <span class="keyword">then</span>

    <span class="keyword">if</span> f(a) <span class="keyword">then</span> <span class="keyword">return</span> a, helper(f, n-1, ...)

    <span class="keyword">else</span>         <span class="keyword">return</span>    helper(f, n-1, ...) <span class="keyword">end</span>

  <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> grep(f, ...)

  <span class="keyword">return</span> helper(f, <span class="library">select</span>(<span class="string">'#'</span>, ...), ...)

<span class="keyword">end</span>

</pre>

</DL>
<p>
<H2>Issue #8: Iterating over Varargs</H2>
<p>
Problem: Iterate over all elements in the vararg.
<p>
<H3>Solution</H3>
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">for</span> n=1,<span class="library">select</span>(<span class="string">'#'</span>,...) <span class="keyword">do</span>

  <span class="keyword">local</span> e = <span class="library">select</span>(n,...)

<span class="keyword">end</span>

</pre>

</DL>
<p>
If you do not need nil elements, you can also use the following:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">for</span> _, e <span class="keyword">in</span> <span class="library">ipairs</span>({...}) <span class="keyword">do</span>

   <span class="comment">-- something with e</span>

<span class="keyword">end</span>

</pre>

</DL>
<p>
If you wish to use an iterator function without creating a garbage table every time, you can use the following:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">do</span>

  <span class="keyword">local</span> i, t, l = 0, {}

  <span class="keyword">local</span> <span class="keyword">function</span> iter(...)

    i = i + 1

    <span class="keyword">if</span> i &gt; l <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>

    <span class="keyword">return</span> i, t[i]

  <span class="keyword">end</span>



  <span class="keyword">function</span> vararg(...)

    i = 0

    l = <span class="library">select</span>(<span class="string">"#"</span>, ...)

    <span class="keyword">for</span> n = 1, l <span class="keyword">do</span>

      t[n] = <span class="library">select</span>(n, ...)

    <span class="keyword">end</span>

    <span class="keyword">for</span> n = l+1, #t <span class="keyword">do</span>

      t[n] = <span class="keyword">nil</span>

    <span class="keyword">end</span>

    <span class="keyword">return</span> iter

  <span class="keyword">end</span>

<span class="keyword">end</span>



<span class="keyword">for</span> i, v <span class="keyword">in</span> vararg(1, <span class="string">"a"</span>, <span class="keyword">false</span>, <span class="keyword">nil</span>) <span class="keyword">do</span> <span class="library">print</span>(i, v) <span class="keyword">end</span> <span class="comment">-- test</span>

<span class="comment">-- Output:</span>

<span class="comment">--   1	1</span>

<span class="comment">--   2	"a"</span>

<span class="comment">--   3	false</span>

<span class="comment">--   4	nil</span>



</pre>

</DL>
<p>
<p>
<H2>Other Comments</H2>
<p>
(none)
<p>
<hr>--<a href="../wiki/DavidManura.html" >DavidManura</a>, 2007, Lua 5.1
<p>
<H2>See Also</H2>
<p>
<UL>
<li> <a href="/lists/lua-l/2004-08/msg00261.html">LuaList:2004-08/msg00261.html</a> "Lua 5.1+ and variable-argument tables"; including <a href="/lists/lua-l/2004-08/msg00408.html">LuaList:2004-08/msg00408.html</a> <a href="/lists/lua-l/2008-04/msg00205.html">LuaList:2008-04/msg00205.html</a> <a href="/lists/lua-l/2006-04/msg00120.html">LuaList:2006-04/msg00120.html</a>
<li> <a href="../wiki/StoringNilsInTables.html" >StoringNilsInTables</a> - often varargs are converted to a table for manipulation since tables are first class objects, but the conversion to a table has limitations of its own, such as concerning <code>nil</code>s and also efficiency.
<li> <a href="../wiki/FunctionalTuples.html" >FunctionalTuples</a> - discussion of a functional approach to implementing tuples
<li> One proposed solution is a new immutable tuple type -- see <a href="../wiki/FeatureProposals.html" >FeatureProposals</a>
</UL>
<hr>
<a href="../wiki/RecentChanges.html" >RecentChanges</a> &middot; <a href="/cgi-bin/wiki.pl?action=editprefs" >preferences</a><br>
<a href="/cgi-bin/wiki.pl?action=edit&amp;id=VarargTheSecondClassCitizen" >edit</a> &middot; <a href="/cgi-bin/wiki.pl?action=history&amp;id=VarargTheSecondClassCitizen" >history</a><br>Last edited March 26, 2011 2:59 am GMT <a href="/cgi-bin/wiki.pl?action=browse&amp;diff=1&amp;id=VarargTheSecondClassCitizen" >(diff)</a>
</body>
</html>