<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>lua-users wiki: Sequence Adapters</TITLE>
<LINK TYPE="text/css" REL="stylesheet" HREF="../styles/main.css">
</HEAD>
<BODY ><table width="100%" border="0"> <tr><td align=left width="100%"><h1><a href="/cgi-bin/wiki.pl?action=search&amp;string=SequenceAdapters&amp;body=1" title="List pages referring to SequenceAdapters">Sequence Adapters</a></h1></td><td align=right>
    <table cellpadding="0" cellspacing="0" border="0" width="1%">
      <tbody>
        <tr>
            <td><a href="../index.html">
            <img src="../images/nav-logo.png" alt="lua-users home" width="177" height="40" border="0"></a></td>
        </tr>
        <tr>
            <td>
            <table cellpadding="0" cellspacing="0" border="0" width="100%">
                <tbody>
                <tr>
                    <td><img src="../images/nav-elbow.png" alt="" width="48" height="40"></td>
                    <td nowrap valign="middle" width="100%">
                        <a href="../wiki/index.html" class="nav">wiki</a></td>
                </tr>
                </tbody>
            </table>
            </td>
        </tr>
      </tbody>
    </table>
<form method="post" action="../wiki/FindPage.html" enctype="application/x-www-form-urlencoded" style="display:inline; margin:0;">
<input type="hidden" name="action" value="search"  /><input type="text" name="string"  size="20" style="" id="search_query1" /><input type="hidden" name="title" value="1"  /><input type="submit" name=".submit" value="Search" /><input type="hidden" name="body" value="on"  /></form></td></tr> </table>
<br clear=all>
<H2>A Need for Better Notation for Sequence Operations</H2>
<p>
Sequences are sequential streams of values that are produced by an iterator function. In the simplest form, they are represented by a function (or callable object) which returns a number of values each time it is called, with <code>nil</code> indicating the end.  Sequences can be single-valued (like <code>io.lines</code>) or multi-valued (like <code>pairs</code>) and mostly they produce values of the same type. It is useful to extract some common operations we use with sequences and tables, and make them available as a library. This is one of the main goals behind the <a href="../wiki/PenlightLibraries.html" >PenlightLibraries</a>. 
<p>
(Please note that this is an idiosyncratic definition: the Lua manual defines <em>sequence</em> as "a table where the set of all positive numeric keys is equal to {1..n} for some integer n" <a href="http://www.lua.org/manual/5.2/manual.html#2.1">[1]</a>.)
<p>
With pl.seq together with the placeholder expressions provided by pl.func we can say:
<p>
<DL>
<dt><dd><pre class="code">
seq.printall(seq.filter(seq.list{1,2,3,4},Gt(_1,2)))

</pre>

</DL>
<p>
Which is fair enough, but awkward; I personally would find it hard to motivate this rather than a simple loop. Of course, this is a toy example, but more complicated combinations become even harder for humans to parse. Sequence adapters make it possible to express the same operation as a method chain:
<p>
<DL>
<dt><dd><pre class="code">
S{1,2,3,4}:filter(Gt(_1,2)):printall()

</pre>

</DL>
<p>
This is more readable, for several reasons. The first is that the qualifying <code>seq.</code> isn't everywhere, and the second is that we are culturally conditioned to read an operation sequence from left to right, unlike function application which is right to left. (This is also the famous pipeline metaphor made so popular by Unix.) Here is another example, where the length operator is mapped over a sequence of strings:
<p>
<DL>
<dt><dd><pre class="code">
S{<span class="string">'one'</span>,<span class="string">'tw'</span>,<span class="string">'t'</span>} :map <span class="string">'#'</span> :printall()  <span class="comment">--&gt; output: 3 2 1</span>

</pre>

</DL>
<p>
It is more interesting to use a real sequence, such as generated by <code>io.lines</code>. This creates a sequence of all unique lines in a file, and then copies it to a table.
<p>
<DL>
<dt><dd><pre class="code">
ls = S(<span class="library">io.lines</span>(fname)):unique():copy()

</pre>

</DL>
<p>
Another pattern which would be very convenient is to apply methods to all elements of the sequence:
<p>
<DL>
<dt><dd><pre class="code">
S{<span class="string">'[one]'</span>,<span class="string">'[two]'</span>,<span class="string">'[three]'</span>}:sub(2,-2):upper():printall() <span class="comment">--&gt; output: ONE TWO THREE</span>

</pre>

</DL>
<p>
Here is a more involved example; given a Lua code string, find all the variable names. <code>lexer.lua</code> will create a double-valued sequence, with the first value the token type and the second the token value. The first value is used to filter the token stream so that only variables ('iden') are passed through; <code>map(_2)</code> only lets the values through, <code>unique</code> collects the names, and finally <code>copy</code> turns these into a table.
<p>
<DL>
<dt><dd><pre class="code">
str = <span class="string">'for i=1,10 do for j = 1,10 do print(i,j) end end'</span>

ls = S(lexer.lua(str)):filter(Eq(_1,<span class="string">'iden'</span>)):map(_2):unique():copy()

<span class="library">print</span>(List(ls))

<span class="comment">---&gt; output: {i,print,j}</span>

</pre>

</DL>
<p>
The source is <a href="https://github.com/stevedonovan/Penlight/blob/master/lua/pl/seq.lua">[here]</a>.
<p>
<H2>Implementation</H2>
<p>
Since there is no type that uniquely indentifies a sequence (apart from it being callable) we need a wrapper object. The iterator function is put inside a table and a metatable is attached so we can control method lookup.
<p>
The <code>__index</code> metamethod is called whenever an unknown method is called, and the method is then looked up in the <code>seq</code> table. However, this function can't be used directly, since (a) it is expecting a sequence as its first argument and (b) it must return its results in a sequence wrapper so we can keep the method chain going.
<p>
<DL>
<dt><dd><pre class="code">
SMT = {

	__index = <span class="keyword">function</span> (tbl,key)

		<span class="keyword">local</span> s = seq[key]

		<span class="keyword">if</span> s <span class="keyword">then</span>

			<span class="keyword">return</span> <span class="keyword">function</span>(sw,...) <span class="keyword">return</span> S(s(sw.iter,...)) <span class="keyword">end</span>

		<span class="keyword">end</span>

	<span class="keyword">end</span>,

}



<span class="keyword">function</span> S (iter)

	<span class="keyword">return</span> <span class="library">setmetatable</span>({iter=iter},SMT)

<span class="keyword">end</span>

</pre>

</DL>
<p>
This demonstrates the concept, but in practice doesn't handle all the necessary cases. Some <code>seq</code> functions return plain values (like <code>reduce</code>) or tables (like <code>copy</code>), and wrapping these would be confusing.  Functions like <code>map</code> have their arguments the wrong way around (function first, then sequence). It would be convenient that <code>S</code> can wrap a table as a sequence, but should not do so for the result of <code>copy</code>. And so forth. And there is still the issue of how to do methods upon the sequence values. The key is this function in <code>seq</code>:
<p>
<DL>
<dt><dd><pre class="code">
<span class="keyword">function</span> mapmethod (iter,name,arg1,arg2)

	<span class="keyword">local</span> val = iter()

	<span class="keyword">local</span> fn = val <span class="keyword">and</span> val[name]

	<span class="keyword">return</span> <span class="keyword">function</span>()

		<span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>

		<span class="keyword">local</span> res = fn(val,arg1,arg2)

		val = iter()

		<span class="keyword">return</span> res

	<span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
<p>
Unlike plain <code>map</code>, <code>mapmethod</code> is given a function <em>name</em>, which it looks up in the first value generated by the sequence - thereafter returns a sequence which is the result of applying that function to every value. (As a convenience, the first two extra arguments are explicitly captured for the function call). So the strategy in the <code>__index</code> metamethod when it cannot look up a function name is to call <code>mapmethod</code> with the name of the method.
<p>
<DL>
<dt><dd><pre class="code">


<span class="comment">-- seqa.lua</span>

<span class="keyword">local</span> seq = <span class="library">require</span> <span class="string">'pl.seq'</span>



<span class="comment">-- can't look these directly up in seq because of the wrong argument order...</span>

<span class="keyword">local</span> overrides = {

	map = <span class="keyword">function</span>(self,fun)

		<span class="keyword">return</span> seq.map(fun,self)

	<span class="keyword">end</span>,

	reduce = <span class="keyword">function</span>(self,fun)

		<span class="keyword">return</span> seq.reduce(fun,self)

	<span class="keyword">end</span>

}



SMT = {

	__index = <span class="keyword">function</span> (tbl,key)

		<span class="keyword">local</span> s = overrides[key] <span class="keyword">or</span> seq[key]

		<span class="keyword">if</span> s <span class="keyword">then</span>

			<span class="keyword">return</span> <span class="keyword">function</span>(sw,...) <span class="keyword">return</span> SW(s(sw.iter,...)) <span class="keyword">end</span>

		<span class="keyword">else</span>

			<span class="keyword">return</span> <span class="keyword">function</span>(sw,...) <span class="keyword">return</span> SW(seq.mapmethod(sw.iter,key,...)) <span class="keyword">end</span>

		<span class="keyword">end</span>

	<span class="keyword">end</span>,

	__call = <span class="keyword">function</span> (sw)

		<span class="keyword">return</span> sw.iter()

	<span class="keyword">end</span>,

}



<span class="keyword">function</span> callable (v)

    <span class="keyword">return</span> <span class="library">type</span>(v) == <span class="string">'function'</span> <span class="keyword">or</span> <span class="library">getmetatable</span>(v) <span class="keyword">and</span> <span class="library">getmetatable</span>(v).__call

<span class="keyword">end</span>



<span class="keyword">function</span> S (iter)

	<span class="keyword">if</span> <span class="keyword">not</span> callable(iter) <span class="keyword">then</span>

		<span class="keyword">if</span> <span class="library">type</span>(iter) == <span class="string">'table'</span> <span class="keyword">then</span> iter = seq.list(iter)

		<span class="keyword">else</span> <span class="keyword">return</span> iter

		<span class="keyword">end</span>

	<span class="keyword">end</span>

	<span class="keyword">return</span> <span class="library">setmetatable</span>({iter=iter},SMT)

<span class="keyword">end</span>



<span class="keyword">function</span> SW (iter)

	<span class="keyword">if</span> callable(iter) <span class="keyword">then</span>

		<span class="keyword">return</span> <span class="library">setmetatable</span>({iter=iter},SMT)

	<span class="keyword">else</span>

		<span class="keyword">return</span> iter

	<span class="keyword">end</span>

<span class="keyword">end</span>

</pre>

</DL>
<p>
<em><a href="../wiki/SteveDonovan.html" >SteveDonovan</a></em>
<hr>
<a href="../wiki/RecentChanges.html" >RecentChanges</a> &middot; <a href="/cgi-bin/wiki.pl?action=editprefs" >preferences</a><br>
<a href="/cgi-bin/wiki.pl?action=edit&amp;id=SequenceAdapters" >edit</a> &middot; <a href="/cgi-bin/wiki.pl?action=history&amp;id=SequenceAdapters" >history</a><br>Last edited July 4, 2012 9:25 am GMT <a href="/cgi-bin/wiki.pl?action=browse&amp;diff=1&amp;id=SequenceAdapters" >(diff)</a>
</body>
</html>