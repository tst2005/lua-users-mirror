<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>lua-users wiki: Hamming Numbers Variant</TITLE>
<LINK TYPE="text/css" REL="stylesheet" HREF="../styles/main.css">
</HEAD>
<BODY ><table width="100%" border="0"> <tr><td align=left width="100%"><h1><a href="/cgi-bin/wiki.pl?action=search&amp;string=HammingNumbersVariant&amp;body=1" title="List pages referring to HammingNumbersVariant">Hamming Numbers Variant</a></h1></td><td align=right>
    <table cellpadding="0" cellspacing="0" border="0" width="1%">
      <tbody>
        <tr>
            <td><a href="../index.html">
            <img src="../images/nav-logo.png" alt="lua-users home" width="177" height="40" border="0"></a></td>
        </tr>
        <tr>
            <td>
            <table cellpadding="0" cellspacing="0" border="0" width="100%">
                <tbody>
                <tr>
                    <td><img src="../images/nav-elbow.png" alt="" width="48" height="40"></td>
                    <td nowrap valign="middle" width="100%">
                        <a href="../wiki/index.html" class="nav">wiki</a></td>
                </tr>
                </tbody>
            </table>
            </td>
        </tr>
      </tbody>
    </table>
<form method="post" action="../wiki/FindPage.html" enctype="application/x-www-form-urlencoded" style="display:inline; margin:0;">
<input type="hidden" name="action" value="search"  /><input type="text" name="string"  size="20" style="" id="search_query1" /><input type="hidden" name="title" value="1"  /><input type="submit" name=".submit" value="Search" /><input type="hidden" name="body" value="on"  /></form></td></tr> </table>
<br clear=all>
Inspired by <a href="../wiki/HammingNumbers.html" >HammingNumbers</a>, this is another program that computes the sequence of Hamming Numbers.  You may want to read that page for more explanation.
<p>
The Hamming numbers are those numbers that are not divisible by any other prime than 2, 3, and 5.  This sequence is A051037 (<a href="http://www.research.att.com/~njas/sequences/A051037">http://www.research.att.com/~njas/sequences/A051037</a>) in Sloane.  The first few Hamming numbers are: 
<p>
<DL>
<dt><dd>1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100,
</DL>
<p>
Our task is to generate these numbers in increasing order.  This task is a well-known example on why lazy lists are useful. In fact, both this code an the one on <a href="../wiki/HammingNumbers.html" >HammingNumbers</a> uses lazy lists as a solution.  A third implementation can be found in Higher Order Perl by Mark Jason Dominus (<a href="http://hop.perl.plover.com/">http://hop.perl.plover.com/</a>).  I'd like to thank the authors of both implementations for the ideas given there.
<p>
So, let's see how the lazy list solution goes.  
<p>
We define a lazy list as a promise to a pair of the first element of the list and the rest of the list.  (Most other people define lazy lists a bit differently: as a pair of the first element and a promise to the rest of the list.  I prefer to use the first approach, but there isn't too much difference here.)
<p>
Now, classically we can generate the Hamming sequence like this:
<p>
<DL>
<dt><dd><pre>

hamming := cons(1, merge(map(x -&gt; 2*x, Hamming), merge(map(x -&gt; 3*x, Hamming), map(x -&gt; 5*x, Hamming))));

</pre>
</DL>
<p>
Here, <em>cons</em>(a, d) makes a list from the first element <em>a</em> and the rest of the list <em>d</em>; <em>map</em>(f, x) returns a list each of whose element is the result of applying the function <em>f</em> to the respective elements of <em>x</em>; <em>merge</em>(a, b) merges two sorted lists to another sorted list; x -&gt; n*x is a unary function that multiples its input by n; and the operations are sufficently lazy.
<p>
This solution uses the fact that a number is Hamming number iff it's equal to 1 or it's 2 times a Hamming number or it's 3 times a Hamming number or it's 5 times a Hamming number.
<p>
The problem with this approach is this.  Some numbers are generated by multiple times.  For example, 6 is both 2 times a Hamming number and 3 times a Hamming number.  Thus, to make this approach work, you have to define merge in such a way that it puts common elements only once to the resulting list.
<p>
However, there's another way to generate the Hamming numbers.  For this, let's call a number Very Hamming iff its only prime divisors are 2 and 3.  Then, we generate the powers of twos, then then Very Hamming numbers from these, and then the Hamming numbers from these.  
<p>
Powers of two are easy: a number is a power of two iff it's 1 or it's 2 times a power of two.  Now notice that a number is Very Hamming iff it's either a power of two or 3 times a Very Hamming number.  Similarly, a number is Hamming iff it's either Very Hamming or it's 5 times a Hamming number.  Notice how this generates every number in each sequence exactly once.
<p>
The corresponding formulae are these.
<p>
<DL>
<dt><dd>two_power := cons(1, map(x -&gt; 2*x, two_power));
</DL>
<p>
<DL>
<dt><dd>very_hamming := merge(two_power, map(x -&gt; 3*x, very_hamming));
</DL>
<p>
<DL>
<dt><dd>hamming := merge(very_hamming, map(x -&gt; 5*x, hamming));
</DL>
<p>
This, however, doesn't work as is.  Here's why.  The equations for the sequences are true, but they are not enough to generate the sequences because when you try to calculate them, you get an infinite loop.  Why is that?
<p>
The first sequence, two_power is fine.  But suppose you want to try to get the first element of the very_hamming list.  For this, you have to calculate the first element of two_power and the first element of map(x -&gt; 3*x, very_hamming), and take the lesser of the two.  But, to calculate the first element of map(x -&gt; 3*x, very_hamming), you have to calculate the first element of very_hamming.  That's an infinite recursion.
<p>
We know that the first element of very_hamming is the first element of two_power, 1.  However, that isn't clear from the definition, because, for that, you'd have to know that the first element of map(x -&gt; 3*x, very_hamming) is greater than 1.  This, however, you can't know before you know the first element of very_hamming.
<p>
To solve this, you have to explicitly tell the program the first few elements of very_hamming and also those of hamming.  After those changes, the algorithm indeed works.
<p>
Now let's see the program.
<p>
The first part is the bignum library I've taken verbatim from <a href="../wiki/HammingNumbers.html" >HammingNumbers</a>.  The second defines promise operations, the third defines pairs.  These two are each treated as abstract data types.  The fourth part defines some functions for lazy lists, including map and merge.  The last section defines the sequence of Hamming numbers and prints some of them.
<p>
<p>
<DL>
<dt><dd><pre class="code">
<span class="comment">-- hamming.lua hamming numbers example</span>

<span class="comment">-- see http://lua-users.org/wiki/HammingNumbers</span>

<span class="comment">-- this code is unoptimized</span>



<span class="comment">-- bignums -----------------------------------------------------------</span>

<span class="comment">-- bignum library</span>



<span class="keyword">do</span>

  <span class="comment">-- very limited bignum stuff; just enough for the examples here.</span>

  <span class="comment">-- Please feel free to improve it.</span>

  <span class="keyword">local</span> base = 1e15

  <span class="keyword">local</span> fmt = <span class="string">"%015.0f"</span>

  <span class="keyword">local</span> meta = {}

  <span class="keyword">function</span> meta:__lt(other)

    <span class="keyword">if</span> self.n ~= other.n <span class="keyword">then</span> <span class="keyword">return</span> self.n &lt; other.n <span class="keyword">end</span>

    <span class="keyword">for</span> i = 1, self.n <span class="keyword">do</span>

      <span class="keyword">if</span> self[i] ~= other[i] <span class="keyword">then</span> <span class="keyword">return</span> self[i] &lt; other[i] <span class="keyword">end</span>

    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="keyword">function</span> meta:__eq(other)

    <span class="keyword">if</span> self.n == other.n <span class="keyword">then</span>

      <span class="keyword">for</span> i = 1, self.n <span class="keyword">do</span>

        <span class="keyword">if</span> self[i] ~= other[i] <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>

      <span class="keyword">end</span>

      <span class="keyword">return</span> <span class="keyword">true</span>

    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="keyword">function</span> meta:__mul(k)

    <span class="comment">-- If the base where a multiple of all possible multipliers, then</span>

    <span class="comment">-- we could figure out the length of the result directly from the</span>

    <span class="comment">-- first "digit". On the other hand, printing the numbers would be</span>

    <span class="comment">-- difficult. So we accept the occasional overflow.</span>

    <span class="keyword">local</span> offset = 0

    <span class="keyword">if</span> self[1] * k &gt;= base <span class="keyword">then</span> offset = 1 <span class="keyword">end</span>

    <span class="keyword">local</span> carry = 0

    <span class="keyword">local</span> result = {}

    <span class="keyword">local</span> n = self.n

    <span class="keyword">for</span> i = n, 1, -1 <span class="keyword">do</span>

      <span class="keyword">local</span> tmp = self[i] * k + carry

      <span class="keyword">local</span> digit = tmp % base

      carry = (tmp - digit) / base

      result[offset + i] = digit

    <span class="keyword">end</span>

    <span class="keyword">if</span> carry ~= 0 <span class="keyword">then</span>

      n = n + 1

      <span class="keyword">if</span> offset == 0 <span class="keyword">then</span>

        <span class="keyword">for</span> i = n, 2, -1 <span class="keyword">do</span>

          result[i] = result[i - 1]

        <span class="keyword">end</span>

      <span class="keyword">end</span>

      result[1] = carry

    <span class="keyword">end</span>

    result.n = n

    <span class="keyword">return</span> <span class="library">setmetatable</span>(result, meta)

  <span class="keyword">end</span>

  <span class="comment">-- Added so that Fib would work; other must be a Bignum</span>

  <span class="keyword">function</span> meta:__add(other)

    <span class="keyword">local</span> result = {}

    <span class="keyword">if</span> self.n &lt; other.n <span class="keyword">then</span> self, other = other, self <span class="keyword">end</span>

    <span class="keyword">local</span> n, m = self.n, other.n

    <span class="keyword">local</span> diff = n - m

    <span class="keyword">local</span> carry = 0

    <span class="keyword">local</span> result = {}

    <span class="keyword">for</span> i = m, 1, -1 <span class="keyword">do</span>

      <span class="keyword">local</span> tmp = self[i + diff] + other[i] + carry

      <span class="keyword">if</span> tmp &lt; base <span class="keyword">then</span>

        carry = 0

      <span class="keyword">else</span>

        tmp = tmp - base

        carry = 1

      <span class="keyword">end</span>

      result[i + diff] = tmp

    <span class="keyword">end</span>

    <span class="keyword">for</span> i = diff, 1, -1 <span class="keyword">do</span>

      <span class="keyword">local</span> tmp = self[i] + carry

      <span class="keyword">if</span> tmp &lt; base <span class="keyword">then</span>

        carry = 0

      <span class="keyword">else</span>

        tmp = tmp - base

        carry = 1

      <span class="keyword">end</span>

      result[i] = tmp

    <span class="keyword">end</span>

    <span class="keyword">if</span> carry &gt; 0 <span class="keyword">then</span>

      n = n + 1

      <span class="keyword">for</span> i = n, 2, -1 <span class="keyword">do</span>

        result[i] = result[i - 1]

      <span class="keyword">end</span>

      result[1] = carry

    <span class="keyword">end</span>

    result.n = n

    <span class="keyword">return</span> <span class="library">setmetatable</span>(result, meta)

  <span class="keyword">end</span>



  <span class="keyword">function</span> meta:__tostring()

    <span class="keyword">local</span> tmp = {}

    tmp[1] = (<span class="string">"%.0f"</span>):format(self[1])

    <span class="keyword">for</span> i = 2, self.n <span class="keyword">do</span>

      tmp[i] = fmt:format(self[i])

    <span class="keyword">end</span>

    <span class="keyword">return</span> <span class="library">table.concat</span>(tmp)

  <span class="keyword">end</span>

  <span class="keyword">function</span> Bignum(k)

    <span class="keyword">return</span> <span class="library">setmetatable</span>({k, n = 1}, meta)

  <span class="keyword">end</span>

<span class="keyword">end</span>





<span class="comment">-- promises ----------------------------------------------------------</span>

<span class="keyword">function</span> delay(f)

	<span class="keyword">return</span> {promise_tag = <span class="keyword">true</span>; promise_func = f};

<span class="keyword">end</span>;

<span class="keyword">function</span> force(p)

	<span class="keyword">if</span> <span class="keyword">not</span> p.promise_tag <span class="keyword">then</span> <span class="library">error</span>(<span class="string">"forcing a non-promise object of type "</span>..<span class="library">type</span>(p)) <span class="keyword">end</span>;

	<span class="keyword">local</span> f = p.promise_func;

	<span class="keyword">if</span> f <span class="keyword">then</span>

		<span class="keyword">local</span> x = f();

		p.promise_val, p.promise_func = x, <span class="keyword">nil</span>;

		<span class="keyword">return</span> x;

	<span class="keyword">else</span>

		<span class="keyword">return</span> p.promise_val;

	<span class="keyword">end</span>;

<span class="keyword">end</span>;





<span class="comment">-- pairs -------------------------------------------------------------</span>

<span class="comment">-- we need only infinite lists so we won't mess with nulls here</span>

<span class="keyword">function</span> cons(a, d)

	<span class="keyword">return</span> {pair_car = a, pair_cdr = d};

<span class="keyword">end</span>;

<span class="keyword">function</span> car(c)

	<span class="keyword">return</span> c.pair_car;

<span class="keyword">end</span>;

<span class="keyword">function</span> cdr(c)

	<span class="keyword">return</span> c.pair_cdr;

<span class="keyword">end</span>;





<span class="comment">-- lazy lists --------------------------------------------------------</span>

<span class="comment">-- a lazy list is a promise to a pair whose cdr is a lazy list</span>



<span class="comment">-- access fields (thus forcing the list)</span>

<span class="keyword">function</span> lcar(l)

	<span class="keyword">return</span> car(force(l));

<span class="keyword">end</span>;

<span class="keyword">function</span> lcdr(l)

	<span class="keyword">return</span> cdr(force(l));

<span class="keyword">end</span>;



<span class="comment">-- map a lazy list</span>

<span class="keyword">function</span> lmap(f, l)

	<span class="keyword">return</span> delay(<span class="keyword">function</span>()

		<span class="keyword">return</span> cons(f(lcar(l)), lmap(f, lcdr(l)));

	<span class="keyword">end</span>);

<span class="keyword">end</span>;



<span class="comment">-- merge two nondecreasing lazy lists to a lazy list</span>

<span class="keyword">function</span> lmerge(a, b)

	<span class="keyword">return</span> delay(<span class="keyword">function</span>()

		<span class="keyword">local</span> x, y = lcar(a), lcar(b);

		<span class="keyword">if</span> x &lt;= y <span class="keyword">then</span>

			<span class="keyword">return</span> cons(x, lmerge(lcdr(a), b));

		<span class="keyword">else</span>

			<span class="keyword">return</span> cons(y, lmerge(a, lcdr(b)));

		<span class="keyword">end</span>;

	<span class="keyword">end</span>);

<span class="keyword">end</span>;





<span class="comment">-- iterate a lazy list</span>

<span class="keyword">function</span> lforeach(f, l)

	f(lcar(l));

	<span class="keyword">return</span> lforeach(f, lcdr(l));

<span class="keyword">end</span>;



<span class="keyword">function</span> lany(f, l)

	x = f(lcar(l));

	<span class="keyword">if</span> x <span class="keyword">then</span>

		<span class="keyword">return</span> x;

	<span class="keyword">else</span>

		<span class="keyword">return</span> lany(f, lcdr(l));

	<span class="keyword">end</span>;

<span class="keyword">end</span>;





<span class="comment">-- main ------------------------------------------------------------</span>

<span class="comment">--dofile "dump.lua";</span>



<span class="comment">-- sequence of natural numbers</span>

<span class="keyword">local</span> N; 

N = delay(<span class="keyword">function</span>() 

	<span class="keyword">return</span> cons(1, lmap(<span class="keyword">function</span>(x) <span class="keyword">return</span> x + 1; <span class="keyword">end</span>, N)) 

<span class="keyword">end</span>);



<span class="comment">-- sequence of Hamming numbers</span>

<span class="keyword">local</span> timeser = <span class="keyword">function</span>(x) <span class="keyword">return</span> <span class="keyword">function</span>(y) <span class="keyword">return</span> y * x; <span class="keyword">end</span>; <span class="keyword">end</span>;

<span class="keyword">local</span> H2; H2 = delay(<span class="keyword">function</span>()

	<span class="keyword">return</span> cons(Bignum(1), lmap(timeser(2), H2));

<span class="keyword">end</span>);

<span class="keyword">local</span> H3; H3 = delay(<span class="keyword">function</span>()

	<span class="keyword">return</span> cons(Bignum(1), 

		delay(<span class="keyword">function</span>() 

			<span class="keyword">return</span> cons(Bignum(2), 

				lcdr(lcdr(lmerge(lmap(timeser(3), H3), H2)))

			);

		<span class="keyword">end</span>)

	);	

<span class="keyword">end</span>);

<span class="keyword">local</span> H5; H5 = delay(<span class="keyword">function</span>()

	<span class="keyword">return</span> cons(Bignum(1), 

		delay(<span class="keyword">function</span>() 

			<span class="keyword">return</span> cons(Bignum(2), 

				lcdr(lcdr(lmerge(lmap(timeser(5), H5), H3)))

			);

		<span class="keyword">end</span>)

	);	

<span class="keyword">end</span>);



<span class="keyword">local</span> n, m = 1, 500005;

lany(<span class="keyword">function</span>(a)

	<span class="keyword">if</span> 0 == n % 50000 <span class="keyword">or</span> n &lt;= 200 <span class="keyword">then</span>

		<span class="library">print</span>(n, a);

	<span class="keyword">end</span>;

	n = n + 1;

	<span class="keyword">return</span> m &lt;= n;

<span class="keyword">end</span>, H5);



<span class="comment">-- END</span>

</pre>

</DL>
<hr>
<a href="../wiki/RecentChanges.html" >RecentChanges</a> &middot; <a href="/cgi-bin/wiki.pl?action=editprefs" >preferences</a><br>
<a href="/cgi-bin/wiki.pl?action=edit&amp;id=HammingNumbersVariant" >edit</a> &middot; <a href="/cgi-bin/wiki.pl?action=history&amp;id=HammingNumbersVariant" >history</a><br>Last edited March 23, 2009 7:28 pm GMT <a href="/cgi-bin/wiki.pl?action=browse&amp;diff=1&amp;id=HammingNumbersVariant" >(diff)</a>
</body>
</html>